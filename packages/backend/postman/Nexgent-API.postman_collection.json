{
	"info": {
		"_postman_id": "nexgent-api-collection",
		"name": "Nexgent AI API",
		"description": "Complete API collection for Nexgent AI backend. This collection includes all authentication, agent, agent balance, trading signal, agent transaction, agent historical swap, trade execution, price feed, wallet, and API key endpoints and can be used for testing and development.\n\n## Setup Instructions\n\n1. Import this collection into Postman\n2. Import the environment file (`Nexgent-API.postman_environment.json`)\n3. Update the `base_url` variable in the environment to match your backend URL\n4. Update the `jwt_secret` variable if needed (should match your backend JWT_SECRET)\n\n## Authentication Flow\n\n### JWT Authentication (Dashboard/UI)\n\n1. **Register** a new user (or use an existing account)\n2. **Login** to get access and refresh tokens\n3. Use the **access token** in the Authorization header for protected endpoints\n4. Use the **refresh token** to get a new access token when it expires\n5. **Logout** to invalidate tokens\n\n### API Key Authentication (External Integrations)\n\n1. **Create an API key** using JWT authentication\n2. **Store the key securely** - it's only shown once at creation\n3. Use the **X-API-Key** header for programmatic access\n4. API keys with `signals` scope can create trading signals\n\n## Environment Variables\n\n- `base_url`: Base URL for the API (default: http://localhost:4000)\n- `access_token`: Automatically set after login\n- `refresh_token`: Automatically set after login\n- `user_id`: Automatically set after login\n- `user_email`: Automatically set after login\n- `agent_id`: Automatically set after creating an agent\n- `balance_id`: Automatically set after creating an agent balance\n- `signal_id`: Automatically set after creating a trading signal\n- `transaction_id`: Automatically set after creating an agent transaction or executing a trade\n- `position_id`: Automatically set after executing a trade (if position created)\n- `swap_id`: Automatically set after creating an agent historical swap\n- `wallet_address`: Automatically set after assigning a wallet\n- `api_key_id`: Automatically set after creating an API key\n- `api_key`: Automatically set after creating an API key (secret - shown only once)\n- `api_key_prefix`: Automatically set after creating an API key\n\n## Notes\n\n- Access tokens expire after 15 minutes (configurable)\n- Refresh tokens expire after 24 hours (configurable)\n- All protected endpoints require the `Authorization: Bearer <access_token>` header\n- The collection automatically manages tokens using Pre-request Scripts and Tests\n- Agent endpoints require authentication and users can only access their own agents\n- Agent balance endpoints require authentication and users can only access balances for their own agents\n- Trading signal POST endpoint requires API key with `signals` scope (rate limited: 120/min)\n- Agent transaction endpoints require authentication and users can only access transactions for their own agents\n- Agent historical swap endpoints require authentication and users can only access swaps for their own agents\n- Trade execution endpoints require authentication and users can only execute trades for their own agents\n- Price feed endpoints require authentication and provide real-time cryptocurrency prices from Pyth Network\n- Wallet endpoints require authentication and provide non-custodial Solana wallet management (wallets loaded from environment variables)\n- API key endpoints require JWT authentication for key management\n- Cache management is available via CLI: `pnpm cache:status`, `pnpm cache:warmup`, `pnpm cache:reset`",
		"schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json"
	},
	"item": [
		{
			"name": "Authentication",
			"item": [
				{
					"name": "Register",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"if (pm.response.code === 201) {",
									"    const response = pm.response.json();",
									"    ",
									"    // Store tokens in environment",
									"    pm.environment.set('access_token', response.accessToken);",
									"    pm.environment.set('refresh_token', response.refreshToken);",
									"    pm.environment.set('user_id', response.user.id);",
									"    pm.environment.set('user_email', response.user.email);",
									"    ",
									"    pm.test('Status code is 201', function () {",
									"        pm.response.to.have.status(201);",
									"    });",
									"    ",
									"    pm.test('Response has access token', function () {",
									"        pm.expect(response).to.have.property('accessToken');",
									"    });",
									"    ",
									"    pm.test('Response has refresh token', function () {",
									"        pm.expect(response).to.have.property('refreshToken');",
									"    });",
									"    ",
									"    pm.test('Response has user object', function () {",
									"        pm.expect(response).to.have.property('user');",
									"        pm.expect(response.user).to.have.property('id');",
									"        pm.expect(response.user).to.have.property('email');",
									"    });",
									"} else {",
									"    pm.test('Request failed', function () {",
									"        pm.response.to.have.status(201);",
									"    });",
									"}"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json",
								"type": "text"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n    \"email\": \"{{user_email}}\",\n    \"password\": \"TestPassword123!\"\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{base_url}}/api/v1/auth/register",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"api",
								"v1",
								"auth",
								"register"
							]
						},
						"description": "Register a new user account.\n\n## Request Body\n\n```json\n{\n    \"email\": \"user@example.com\",\n    \"password\": \"SecurePassword123!\"\n}\n```\n\n## Password Requirements\n\n- Minimum 8 characters\n- Maximum 128 characters\n- At least one uppercase letter\n- At least one lowercase letter\n- At least one number\n- At least one special character\n\n## Response\n\n```json\n{\n    \"accessToken\": \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...\",\n    \"refreshToken\": \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...\",\n    \"user\": {\n        \"id\": \"uuid\",\n        \"email\": \"user@example.com\",\n        \"createdAt\": \"2025-01-27T00:00:00.000Z\"\n    }\n}\n```\n\n## Error Responses\n\n- `400`: Invalid input (missing email/password, invalid email format, weak password)\n- `500`: Internal server error"
					},
					"response": []
				},
				{
					"name": "Login",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"if (pm.response.code === 200) {",
									"    const response = pm.response.json();",
									"    ",
									"    // Store tokens in environment",
									"    pm.environment.set('access_token', response.accessToken);",
									"    pm.environment.set('refresh_token', response.refreshToken);",
									"    pm.environment.set('user_id', response.user.id);",
									"    pm.environment.set('user_email', response.user.email);",
									"    ",
									"    pm.test('Status code is 200', function () {",
									"        pm.response.to.have.status(200);",
									"    });",
									"    ",
									"    pm.test('Response has access token', function () {",
									"        pm.expect(response).to.have.property('accessToken');",
									"    });",
									"    ",
									"    pm.test('Response has refresh token', function () {",
									"        pm.expect(response).to.have.property('refreshToken');",
									"    });",
									"    ",
									"    pm.test('Response has user object', function () {",
									"        pm.expect(response).to.have.property('user');",
									"        pm.expect(response.user).to.have.property('id');",
									"        pm.expect(response.user).to.have.property('email');",
									"    });",
									"} else if (pm.response.code === 423) {",
									"    pm.test('Account is locked', function () {",
									"        pm.response.to.have.status(423);",
									"    });",
									"} else {",
									"    pm.test('Login failed', function () {",
									"        pm.response.to.have.status(200);",
									"    });",
									"}"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json",
								"type": "text"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n    \"email\": \"{{user_email}}\",\n    \"password\": \"TestPassword123!\",\n    \"rememberMe\": false\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{base_url}}/api/v1/auth/login",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"api",
								"v1",
								"auth",
								"login"
							]
						},
						"description": "Authenticate a user and receive access and refresh tokens.\n\n## Request Body\n\n```json\n{\n    \"email\": \"user@example.com\",\n    \"password\": \"SecurePassword123!\",\n    \"rememberMe\": false\n}\n```\n\n## Parameters\n\n- `email` (required): User's email address\n- `password` (required): User's password\n- `rememberMe` (optional): If true, refresh token expires in 30 days instead of 24 hours\n\n## Response\n\n```json\n{\n    \"accessToken\": \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...\",\n    \"refreshToken\": \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...\",\n    \"user\": {\n        \"id\": \"uuid\",\n        \"email\": \"user@example.com\",\n        \"createdAt\": \"2025-01-27T00:00:00.000Z\"\n    }\n}\n```\n\n## Error Responses\n\n- `400`: Invalid input (missing email/password)\n- `401`: Invalid email or password\n- `423`: Account is locked due to too many failed login attempts\n- `500`: Internal server error\n\n## Security Features\n\n- Account lockout after 5 failed attempts\n- Constant-time password verification (prevents timing attacks)\n- Generic error messages (prevents email enumeration)"
					},
					"response": []
				},
				{
					"name": "Refresh Token",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"if (pm.response.code === 200) {",
									"    const response = pm.response.json();",
									"    ",
									"    // Update access token in environment",
									"    pm.environment.set('access_token', response.accessToken);",
									"    ",
									"    pm.test('Status code is 200', function () {",
									"        pm.response.to.have.status(200);",
									"    });",
									"    ",
									"    pm.test('Response has access token', function () {",
									"        pm.expect(response).to.have.property('accessToken');",
									"    });",
									"} else {",
									"    pm.test('Token refresh failed', function () {",
									"        pm.response.to.have.status(200);",
									"    });",
									"}"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json",
								"type": "text"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n    \"refreshToken\": \"{{refresh_token}}\"\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{base_url}}/api/v1/auth/refresh",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"api",
								"v1",
								"auth",
								"refresh"
							]
						},
						"description": "Refresh an expired access token using a valid refresh token.\n\n## Request Body\n\n```json\n{\n    \"refreshToken\": \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...\"\n}\n```\n\n## Response\n\n```json\n{\n    \"accessToken\": \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...\"\n}\n```\n\n## Error Responses\n\n- `400`: Missing refresh token\n- `401`: Invalid or expired refresh token\n- `500`: Internal server error\n\n## Notes\n\n- Refresh tokens expire after 24 hours (or 30 days if rememberMe was true)\n- Access tokens expire after 15 minutes\n- The new access token is automatically stored in the environment"
					},
					"response": []
				},
				{
					"name": "Get Current User",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"// Check if access token exists",
									"if (!pm.environment.get('access_token')) {",
									"    throw new Error('Access token not found. Please login first.');",
									"}"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test('Status code is 200', function () {",
									"    pm.response.to.have.status(200);",
									"});",
									"",
									"pm.test('Response has user id', function () {",
									"    const response = pm.response.json();",
									"    pm.expect(response).to.have.property('id');",
									"});",
									"",
									"pm.test('Response has user email', function () {",
									"    const response = pm.response.json();",
									"    pm.expect(response).to.have.property('email');",
									"});",
									"",
									"pm.test('Response has createdAt', function () {",
									"    const response = pm.response.json();",
									"    pm.expect(response).to.have.property('createdAt');",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": [
								{
									"key": "token",
									"value": "{{access_token}}",
									"type": "string"
								}
							]
						},
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{base_url}}/api/v1/auth/me",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"api",
								"v1",
								"auth",
								"me"
							]
						},
						"description": "Get information about the currently authenticated user.\n\n## Headers\n\n```\nAuthorization: Bearer <access_token>\n```\n\n## Response\n\n```json\n{\n    \"id\": \"uuid\",\n    \"email\": \"user@example.com\",\n    \"createdAt\": \"2025-01-27T00:00:00.000Z\"\n}\n```\n\n## Error Responses\n\n- `401`: Unauthorized (missing or invalid token)\n- `404`: User not found\n- `500`: Internal server error\n\n## Notes\n\n- Requires authentication (access token in Authorization header)\n- Returns fresh user data from the database"
					},
					"response": []
				},
				{
					"name": "Logout",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"// Check if access token exists",
									"if (!pm.environment.get('access_token')) {",
									"    throw new Error('Access token not found. Please login first.');",
									"}"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"if (pm.response.code === 200) {",
									"    // Clear tokens from environment",
									"    pm.environment.unset('access_token');",
									"    pm.environment.unset('refresh_token');",
									"    pm.environment.unset('user_id');",
									"    pm.environment.unset('user_email');",
									"    ",
									"    pm.test('Status code is 200', function () {",
									"        pm.response.to.have.status(200);",
									"    });",
									"    ",
									"    pm.test('Response indicates success', function () {",
									"        const response = pm.response.json();",
									"        pm.expect(response).to.have.property('success');",
									"        pm.expect(response.success).to.be.true;",
									"    });",
									"} else {",
									"    pm.test('Logout failed', function () {",
									"        pm.response.to.have.status(200);",
									"    });",
									"}"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": [
								{
									"key": "token",
									"value": "{{access_token}}",
									"type": "string"
								}
							]
						},
						"method": "POST",
						"header": [],
						"url": {
							"raw": "{{base_url}}/api/v1/auth/logout",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"api",
								"v1",
								"auth",
								"logout"
							]
						},
						"description": "Logout the currently authenticated user.\n\n## Headers\n\n```\nAuthorization: Bearer <access_token>\n```\n\n## Response\n\n```json\n{\n    \"success\": true,\n    \"message\": \"Logged out successfully\"\n}\n```\n\n## Error Responses\n\n- `401`: Unauthorized (missing or invalid token)\n- `500`: Internal server error\n\n## Notes\n\n- Requires authentication (access token in Authorization header)\n- Currently returns success immediately (token blacklisting via Redis should be implemented for immediate token invalidation)\n- Tokens are automatically cleared from the environment after successful logout"
					},
					"response": []
				}
			],
			"description": "Authentication endpoints for user registration, login, token management, and user information."
		},
		{
			"name": "Agents",
			"item": [
				{
					"name": "Create Agent",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"// Check if access token exists",
									"if (!pm.environment.get('access_token')) {",
									"    throw new Error('Access token not found. Please login first.');",
									"}"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"if (pm.response.code === 201) {",
									"    const response = pm.response.json();",
									"    ",
									"    // Store agent ID in environment",
									"    pm.environment.set('agent_id', response.id);",
									"    ",
									"    pm.test('Status code is 201', function () {",
									"        pm.response.to.have.status(201);",
									"    });",
									"    ",
									"    pm.test('Response has agent id', function () {",
									"        pm.expect(response).to.have.property('id');",
									"    });",
									"    ",
									"    pm.test('Response has agent name', function () {",
									"        pm.expect(response).to.have.property('name');",
									"    });",
									"    ",
									"    pm.test('Response has userId', function () {",
									"        pm.expect(response).to.have.property('userId');",
									"    });",
									"    ",
									"    pm.test('Response has createdAt', function () {",
									"        pm.expect(response).to.have.property('createdAt');",
									"    });",
									"    ",
									"    pm.test('Response has updatedAt', function () {",
									"        pm.expect(response).to.have.property('updatedAt');",
									"    });",
									"} else {",
									"    pm.test('Request failed', function () {",
									"        pm.response.to.have.status(201);",
									"    });",
									"}"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": [
								{
									"key": "token",
									"value": "{{access_token}}",
									"type": "string"
								}
							]
						},
						"method": "POST",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json",
								"type": "text"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n    \"name\": \"My First Agent\",\n    \"bio\": \"This is my agent bio\"\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{base_url}}/api/v1/agents",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"api",
								"v1",
								"agents"
							]
						},
						"description": "Create a new agent for the authenticated user.\n\n## Headers\n\n```\nAuthorization: Bearer <access_token>\n```\n\n## Request Body\n\n```json\n{\n    \"name\": \"My First Agent\",\n    \"bio\": \"This is my agent bio\"\n}\n```\n\n## Parameters\n\n- `name` (required): Agent name (max 255 characters)\n- `bio` (optional): Agent bio/description\n\n## Response\n\n```json\n{\n    \"id\": \"uuid\",\n    \"userId\": \"uuid\",\n    \"name\": \"My First Agent\",\n    \"bio\": \"This is my agent bio\",\n    \"createdAt\": \"2025-01-27T00:00:00.000Z\",\n    \"updatedAt\": \"2025-01-27T00:00:00.000Z\"\n}\n```\n\n## Error Responses\n\n- `400`: Invalid input (missing name, name too long)\n- `401`: Unauthorized (missing or invalid token)\n- `500`: Internal server error\n\n## Notes\n\n- Requires authentication (access token in Authorization header)\n- Agent is automatically associated with the authenticated user\n- Agent ID is automatically stored in the environment for use in other requests"
					},
					"response": []
				},
				{
					"name": "List Agents",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"// Check if access token exists",
									"if (!pm.environment.get('access_token')) {",
									"    throw new Error('Access token not found. Please login first.');",
									"}"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test('Status code is 200', function () {",
									"    pm.response.to.have.status(200);",
									"});",
									"",
									"pm.test('Response is an array', function () {",
									"    const response = pm.response.json();",
									"    pm.expect(response).to.be.an('array');",
									"});",
									"",
									"pm.test('Each agent has required fields', function () {",
									"    const agents = pm.response.json();",
									"    if (agents.length > 0) {",
									"        const agent = agents[0];",
									"        pm.expect(agent).to.have.property('id');",
									"        pm.expect(agent).to.have.property('userId');",
									"        pm.expect(agent).to.have.property('name');",
									"        pm.expect(agent).to.have.property('createdAt');",
									"        pm.expect(agent).to.have.property('updatedAt');",
									"    }",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": [
								{
									"key": "token",
									"value": "{{access_token}}",
									"type": "string"
								}
							]
						},
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{base_url}}/api/v1/agents",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"api",
								"v1",
								"agents"
							]
						},
						"description": "Get all agents for the authenticated user.\n\n## Headers\n\n```\nAuthorization: Bearer <access_token>\n```\n\n## Response\n\n```json\n[\n    {\n        \"id\": \"uuid\",\n        \"userId\": \"uuid\",\n        \"name\": \"My First Agent\",\n        \"bio\": \"This is my agent bio\",\n        \"createdAt\": \"2025-01-27T00:00:00.000Z\",\n        \"updatedAt\": \"2025-01-27T00:00:00.000Z\"\n    }\n]\n```\n\n## Error Responses\n\n- `401`: Unauthorized (missing or invalid token)\n- `500`: Internal server error\n\n## Notes\n\n- Requires authentication (access token in Authorization header)\n- Returns only agents belonging to the authenticated user\n- Agents are ordered by creation date (most recent first)\n- Returns an empty array if the user has no agents"
					},
					"response": []
				},
				{
					"name": "Get Agent",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"// Check if access token exists",
									"if (!pm.environment.get('access_token')) {",
									"    throw new Error('Access token not found. Please login first.');",
									"}"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test('Status code is 200', function () {",
									"    pm.response.to.have.status(200);",
									"});",
									"",
									"pm.test('Response has agent id', function () {",
									"    const response = pm.response.json();",
									"    pm.expect(response).to.have.property('id');",
									"});",
									"",
									"pm.test('Response has agent name', function () {",
									"    const response = pm.response.json();",
									"    pm.expect(response).to.have.property('name');",
									"});",
									"",
									"pm.test('Response has userId', function () {",
									"    const response = pm.response.json();",
									"    pm.expect(response).to.have.property('userId');",
									"});",
									"",
									"pm.test('Response has createdAt', function () {",
									"    const response = pm.response.json();",
									"    pm.expect(response).to.have.property('createdAt');",
									"});",
									"",
									"pm.test('Response has updatedAt', function () {",
									"    const response = pm.response.json();",
									"    pm.expect(response).to.have.property('updatedAt');",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": [
								{
									"key": "token",
									"value": "{{access_token}}",
									"type": "string"
								}
							]
						},
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{base_url}}/api/v1/agents/{{agent_id}}",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"api",
								"v1",
								"agents",
								"{{agent_id}}"
							]
						},
						"description": "Get a specific agent by ID.\n\n## Headers\n\n```\nAuthorization: Bearer <access_token>\n```\n\n## Path Parameters\n\n- `id`: Agent ID (UUID)\n\n## Response\n\n```json\n{\n    \"id\": \"uuid\",\n    \"userId\": \"uuid\",\n    \"name\": \"My First Agent\",\n    \"bio\": \"This is my agent bio\",\n    \"createdAt\": \"2025-01-27T00:00:00.000Z\",\n    \"updatedAt\": \"2025-01-27T00:00:00.000Z\"\n}\n```\n\n## Error Responses\n\n- `400`: Invalid agent ID format\n- `401`: Unauthorized (missing or invalid token)\n- `404`: Agent not found\n- `500`: Internal server error\n\n## Notes\n\n- Requires authentication (access token in Authorization header)\n- Only returns agents belonging to the authenticated user\n- Returns 404 if the agent doesn't exist or doesn't belong to the user\n- Use `{{agent_id}}` environment variable or provide a valid UUID"
					},
					"response": []
				},
				{
					"name": "Update Agent",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"// Check if access token exists",
									"if (!pm.environment.get('access_token')) {",
									"    throw new Error('Access token not found. Please login first.');",
									"}"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test('Status code is 200', function () {",
									"    pm.response.to.have.status(200);",
									"});",
									"",
									"pm.test('Response has agent id', function () {",
									"    const response = pm.response.json();",
									"    pm.expect(response).to.have.property('id');",
									"});",
									"",
									"pm.test('Response has updated name', function () {",
									"    const response = pm.response.json();",
									"    pm.expect(response).to.have.property('name');",
									"});",
									"",
									"pm.test('Response has updatedAt', function () {",
									"    const response = pm.response.json();",
									"    pm.expect(response).to.have.property('updatedAt');",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": [
								{
									"key": "token",
									"value": "{{access_token}}",
									"type": "string"
								}
							]
						},
						"method": "PUT",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json",
								"type": "text"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n    \"name\": \"Updated Agent Name\",\n    \"bio\": \"Updated agent bio\"\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{base_url}}/api/v1/agents/{{agent_id}}",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"api",
								"v1",
								"agents",
								"{{agent_id}}"
							]
						},
						"description": "Update an existing agent.\n\n## Headers\n\n```\nAuthorization: Bearer <access_token>\n```\n\n## Path Parameters\n\n- `id`: Agent ID (UUID)\n\n## Request Body\n\n```json\n{\n    \"name\": \"Updated Agent Name\",\n    \"bio\": \"Updated agent bio\"\n}\n```\n\n## Parameters\n\n- `name` (optional): Updated agent name (max 255 characters)\n- `bio` (optional): Updated agent bio/description\n\n## Response\n\n```json\n{\n    \"id\": \"uuid\",\n    \"userId\": \"uuid\",\n    \"name\": \"Updated Agent Name\",\n    \"bio\": \"Updated agent bio\",\n    \"createdAt\": \"2025-01-27T00:00:00.000Z\",\n    \"updatedAt\": \"2025-01-27T00:00:01.000Z\"\n}\n```\n\n## Error Responses\n\n- `400`: Invalid input (invalid ID format, invalid name, at least one field required)\n- `401`: Unauthorized (missing or invalid token)\n- `404`: Agent not found\n- `500`: Internal server error\n\n## Notes\n\n- Requires authentication (access token in Authorization header)\n- Only allows updating own agents\n- At least one field (name or bio) must be provided\n- Returns 404 if the agent doesn't exist or doesn't belong to the user\n- Use `{{agent_id}}` environment variable or provide a valid UUID"
					},
					"response": []
				},
				{
					"name": "Delete Agent",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"// Check if access token exists",
									"if (!pm.environment.get('access_token')) {",
									"    throw new Error('Access token not found. Please login first.');",
									"}"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"if (pm.response.code === 200) {",
									"    // Clear agent_id from environment after deletion",
									"    pm.environment.unset('agent_id');",
									"    ",
									"    pm.test('Status code is 200', function () {",
									"        pm.response.to.have.status(200);",
									"    });",
									"    ",
									"    pm.test('Response indicates success', function () {",
									"        const response = pm.response.json();",
									"        pm.expect(response).to.have.property('success');",
									"        pm.expect(response.success).to.be.true;",
									"    });",
									"} else {",
									"    pm.test('Delete failed', function () {",
									"        pm.response.to.have.status(200);",
									"    });",
									"}"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": [
								{
									"key": "token",
									"value": "{{access_token}}",
									"type": "string"
								}
							]
						},
						"method": "DELETE",
						"header": [],
						"url": {
							"raw": "{{base_url}}/api/v1/agents/{{agent_id}}",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"api",
								"v1",
								"agents",
								"{{agent_id}}"
							]
						},
						"description": "Delete an agent.\n\n## Headers\n\n```\nAuthorization: Bearer <access_token>\n```\n\n## Path Parameters\n\n- `id`: Agent ID (UUID)\n\n## Response\n\n```json\n{\n    \"success\": true,\n    \"message\": \"Agent deleted successfully\"\n}\n```\n\n## Error Responses\n\n- `400`: Invalid agent ID format\n- `401`: Unauthorized (missing or invalid token)\n- `404`: Agent not found\n- `500`: Internal server error\n\n## Notes\n\n- Requires authentication (access token in Authorization header)\n- Only allows deleting own agents\n- Returns 404 if the agent doesn't exist or doesn't belong to the user\n- Agent ID is automatically cleared from the environment after successful deletion\n- Use `{{agent_id}}` environment variable or provide a valid UUID"
					},
					"response": []
				},
				{
					"name": "Get Agent Trading Config",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"// Check if access token exists",
									"if (!pm.environment.get('access_token')) {",
									"    throw new Error('Access token not found. Please login first.');",
									"}"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test('Status code is 200', function () {",
									"    pm.response.to.have.status(200);",
									"});",
									"",
									"pm.test('Response has config object', function () {",
									"    const response = pm.response.json();",
									"    pm.expect(response).to.have.property('config');",
									"    pm.expect(response.config).to.be.an('object');",
									"});",
									"",
									"pm.test('Config has required fields', function () {",
									"    const response = pm.response.json();",
									"    const config = response.config;",
									"    pm.expect(config).to.have.property('purchaseLimits');",
									"    pm.expect(config).to.have.property('stopLoss');",
									"    pm.expect(config).to.have.property('positionCalculator');",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": [
								{
									"key": "token",
									"value": "{{access_token}}",
									"type": "string"
								}
							]
						},
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{base_url}}/api/v1/agents/{{agent_id}}/config",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"api",
								"v1",
								"agents",
								"{{agent_id}}",
								"config"
							]
						},
						"description": "Get the trading configuration for an agent.\n\n## Headers\n\n```\nAuthorization: Bearer <access_token>\n```\n\n## Path Parameters\n\n- `id`: Agent ID (UUID)\n\n## Response\n\n```json\n{\n    \"config\": {\n        \"purchaseLimits\": {\n            \"min\": 0.1,\n            \"max\": 2.0\n        },\n        \"stopLoss\": {\n            \"enabled\": true,\n            \"defaultPercentage\": -32,\n            \"trailingLevels\": [...],\n            \"continuousTrailing\": {...}\n        },\n        \"positionCalculator\": {...}\n    }\n}\n```\n\n## Error Responses\n\n- `400`: Invalid agent ID format or invalid configuration\n- `401`: Unauthorized (missing or invalid token)\n- `404`: Agent not found\n- `500`: Internal server error\n\n## Notes\n\n- Requires authentication (access token in Authorization header)\n- Only returns config for own agents\n- Configuration is merged with defaults before returning\n- Uses cache for performance\n- Use `{{agent_id}}` environment variable or provide a valid UUID"
					},
					"response": []
				},
				{
					"name": "Update Agent Trading Config",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"// Check if access token exists",
									"if (!pm.environment.get('access_token')) {",
									"    throw new Error('Access token not found. Please login first.');",
									"}"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"if (pm.response.code === 200) {",
									"    pm.test('Status code is 200', function () {",
									"        pm.response.to.have.status(200);",
									"    });",
									"    ",
									"    pm.test('Response has config object', function () {",
									"        const response = pm.response.json();",
									"        pm.expect(response).to.have.property('config');",
									"        pm.expect(response.config).to.be.an('object');",
									"    });",
									"} else {",
									"    pm.test('Update failed', function () {",
									"        pm.response.to.have.status(200);",
									"    });",
									"}"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": [
								{
									"key": "token",
									"value": "{{access_token}}",
									"type": "string"
								}
							]
						},
						"method": "PUT",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json",
								"type": "text"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n    \"config\": {\n        \"purchaseLimits\": {\n            \"min\": 0.2,\n            \"max\": 1.5\n        },\n        \"stopLoss\": {\n            \"enabled\": true,\n            \"defaultPercentage\": -30,\n            \"trailingLevels\": [\n                { \"change\": 100, \"stopLoss\": 60 },\n                { \"change\": 50, \"stopLoss\": 20 }\n            ],\n            \"continuousTrailing\": {\n                \"enabled\": true,\n                \"minStopLossPercentage\": 5,\n                \"curveFunction\": \"linear\"\n            }\n        }\n    }\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{base_url}}/api/v1/agents/{{agent_id}}/config",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"api",
								"v1",
								"agents",
								"{{agent_id}}",
								"config"
							]
						},
						"description": "Update the trading configuration for an agent. Performs deep merge with existing configuration.\n\n## Headers\n\n```\nAuthorization: Bearer <access_token>\nContent-Type: application/json\n```\n\n## Path Parameters\n\n- `id`: Agent ID (UUID)\n\n## Request Body\n\nPartial configuration update. Only provided fields will be merged with existing config.\n\n```json\n{\n    \"config\": {\n        \"purchaseLimits\": {\n            \"min\": 0.2,\n            \"max\": 1.5\n        },\n        \"stopLoss\": {\n            \"enabled\": true,\n            \"defaultPercentage\": -30,\n            \"trailingLevels\": [\n                { \"change\": 100, \"stopLoss\": 60 },\n                { \"change\": 50, \"stopLoss\": 20 }\n            ],\n            \"continuousTrailing\": {\n                \"enabled\": true,\n                \"minStopLossPercentage\": 5,\n                \"curveFunction\": \"linear\"\n            }\n        },\n        \"positionCalculator\": {\n            \"solBalanceThresholds\": {\n                \"minimum\": 0.2,\n                \"medium\": 5,\n                \"large\": 10\n            }\n        }\n    }\n}\n```\n\nTo reset to defaults, send:\n```json\n{\n    \"config\": null\n}\n```\n\n## Response\n\nReturns the complete merged configuration (with defaults applied).\n\n```json\n{\n    \"config\": {\n        \"purchaseLimits\": {...},\n        \"stopLoss\": {...},\n        \"positionCalculator\": {...}\n    }\n}\n```\n\n## Error Responses\n\n- `400`: Invalid agent ID format, invalid configuration, or validation errors\n- `401`: Unauthorized (missing or invalid token)\n- `404`: Agent not found\n- `500`: Internal server error\n\n## Notes\n\n- Requires authentication (access token in Authorization header)\n- Only allows updating own agents\n- Partial updates are supported (deep merge)\n- Configuration is validated before saving\n- Cache is invalidated on update\n- Use `{{agent_id}}` environment variable or provide a valid UUID\n- Send `null` for config to reset to defaults"
					},
					"response": []
				},
				{
					"name": "Get Agent Balance History",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"// Check if access token exists",
									"if (!pm.environment.get('access_token')) {",
									"    throw new Error('Access token not found. Please login first.');",
									"}"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"if (pm.response.code === 200) {",
									"    const response = pm.response.json();",
									"    ",
									"    pm.test('Status code is 200', function () {",
									"        pm.response.to.have.status(200);",
									"    });",
									"    ",
									"    pm.test('Response has required fields', function () {",
									"        pm.expect(response).to.have.property('agentId');",
									"        pm.expect(response).to.have.property('timeframe');",
									"        pm.expect(response).to.have.property('snapshots');",
									"        pm.expect(response.snapshots).to.be.an('array');",
									"    });",
									"    ",
									"    if (response.snapshots.length > 0) {",
									"        pm.test('Snapshot has required fields', function () {",
									"            const snapshot = response.snapshots[0];",
									"            pm.expect(snapshot).to.have.property('timestamp');",
									"            pm.expect(snapshot).to.have.property('portfolioBalanceSol');",
									"            pm.expect(snapshot).to.have.property('solBalance');",
									"            pm.expect(snapshot).to.have.property('positionsValueSol');",
									"            pm.expect(snapshot).to.have.property('unrealizedPnLSol');",
									"        });",
									"    }",
									"} else if (pm.response.code === 400) {",
									"    pm.test('Bad request for invalid timeframe', function () {",
									"        pm.response.to.have.status(400);",
									"    });",
									"} else if (pm.response.code === 404) {",
									"    pm.test('Agent not found', function () {",
									"        pm.response.to.have.status(404);",
									"    });",
									"}"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": [
								{
									"key": "token",
									"value": "{{access_token}}",
									"type": "string"
								}
							]
						},
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{base_url}}/api/v1/agents/{{agent_id}}/balance-history?timeframe=all",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"api",
								"v1",
								"agents",
								"{{agent_id}}",
								"balance-history"
							],
							"query": [
								{
									"key": "timeframe",
									"value": "all",
									"description": "Timeframe: '24h' for hourly snapshots (last 24 hours), 'all' for daily snapshots (midnight only)"
								}
							]
						},
						"description": "Get balance history snapshots for an agent. Returns hourly snapshots for the last 24 hours, or daily snapshots (midnight only) for all time.\n\n## Headers\n\n```\nAuthorization: Bearer <access_token>\n```\n\n## Path Parameters\n\n- `id`: Agent ID (UUID)\n\n## Query Parameters\n\n- `timeframe` (optional): Timeframe for snapshots\n  - `'24h'`: Returns hourly snapshots from the last 24 hours\n  - `'all'` (default): Returns daily snapshots (midnight/00:00 only, one per day)\n\n## Response\n\n```json\n{\n    \"agentId\": \"uuid\",\n    \"timeframe\": \"all\",\n    \"snapshots\": [\n        {\n            \"timestamp\": \"2025-01-27T00:00:00.000Z\",\n            \"portfolioBalanceSol\": \"10.50000000\",\n            \"solBalance\": \"8.20000000\",\n            \"positionsValueSol\": \"2.30000000\",\n            \"unrealizedPnLSol\": \"0.50000000\"\n        },\n        {\n            \"timestamp\": \"2025-01-28T00:00:00.000Z\",\n            \"portfolioBalanceSol\": \"11.20000000\",\n            \"solBalance\": \"8.50000000\",\n            \"positionsValueSol\": \"2.70000000\",\n            \"unrealizedPnLSol\": \"0.80000000\"\n        }\n    ]\n}\n```\n\n## Response Fields\n\n### Top Level\n- `agentId` (string): Agent ID (UUID)\n- `timeframe` (string): The timeframe used ('24h' or 'all')\n- `snapshots` (array): Array of balance snapshots\n\n### Snapshot Object\n- `timestamp` (string): Snapshot timestamp (ISO 8601)\n- `portfolioBalanceSol` (string): Total portfolio balance in SOL (wallet + positions)\n- `solBalance` (string): SOL balance in wallet only\n- `positionsValueSol` (string): Current value of all positions in SOL\n- `unrealizedPnLSol` (string): Unrealized profit/loss in SOL\n\n## Error Responses\n\n- `400`: Invalid agent ID format or invalid timeframe (must be '24h' or 'all')\n- `401`: Unauthorized (missing or invalid token)\n- `404`: Agent not found\n- `500`: Internal server error\n\n## Notes\n\n- Requires authentication (access token in Authorization header)\n- Only returns snapshots for agents owned by the authenticated user\n- Snapshots are sorted by timestamp (ascending, oldest first)\n- For '24h' timeframe: Returns hourly snapshots from the last 24-25 hours (includes buffer)\n- For 'all' timeframe: Returns only daily snapshots captured at midnight (00:00 UTC)\n- Balance values are returned as strings to preserve precision (Decimal type)\n- Snapshots are captured hourly via scheduled job\n- Use `{{agent_id}}` environment variable or provide a valid UUID"
					},
					"response": []
				}
			],
			"description": "Agent management endpoints for creating, reading, updating, and deleting agents, as well as managing trading configurations. All endpoints require authentication and users can only access their own agents."
		},
		{
			"name": "Agent Positions",
			"item": [
				{
					"name": "Get Agent Positions",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"// Check if access token exists",
									"if (!pm.environment.get('access_token')) {",
									"    throw new Error('Access token not found. Please login first.');",
									"}"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"if (pm.response.code === 200) {",
									"    const response = pm.response.json();",
									"    ",
									"    pm.test('Status code is 200', function () {",
									"        pm.response.to.have.status(200);",
									"    });",
									"    ",
									"    pm.test('Response is an array', function () {",
									"        pm.expect(response).to.be.an('array');",
									"    });",
									"    ",
									"    if (response.length > 0) {",
									"        pm.test('First position has required fields', function () {",
									"            const position = response[0];",
									"            pm.expect(position).to.have.property('id');",
									"            pm.expect(position).to.have.property('agentId');",
									"            pm.expect(position).to.have.property('tokenAddress');",
									"            pm.expect(position).to.have.property('tokenSymbol');",
									"            pm.expect(position).to.have.property('purchase');",
									"            pm.expect(position.purchase).to.have.property('priceNative');",
									"            pm.expect(position.purchase).to.have.property('priceUsd');",
									"            pm.expect(position.purchase).to.have.property('amount');",
									"            pm.expect(position.purchase).to.have.property('transaction');",
									"            pm.expect(position).to.have.property('current');",
									"            pm.expect(position.current).to.have.property('priceNative');",
									"            pm.expect(position.current).to.have.property('priceUsd');",
									"            pm.expect(position.current).to.have.property('valueNative');",
									"            pm.expect(position.current).to.have.property('valueUsd');",
									"            pm.expect(position).to.have.property('profitLoss');",
									"            pm.expect(position.profitLoss).to.have.property('native');",
									"            pm.expect(position.profitLoss).to.have.property('usd');",
									"            pm.expect(position.profitLoss).to.have.property('percent');",
									"            pm.expect(position.profitLoss).to.have.property('priceChangePercent');",
									"            pm.expect(position).to.have.property('stopLoss');",
									"            pm.expect(position.stopLoss).to.have.property('percentage');",
									"            pm.expect(position.stopLoss).to.have.property('peakPrice');",
									"        });",
									"        ",
									"        pm.test('First position has take-profit fields', function () {",
									"            const position = response[0];",
									"            pm.expect(position).to.have.property('takeProfit');",
									"            pm.expect(position.takeProfit).to.have.property('levelsHit');",
									"            pm.expect(position.takeProfit).to.have.property('remainingAmount');",
									"            pm.expect(position.takeProfit).to.have.property('originalAmount');",
									"            pm.expect(position.takeProfit).to.have.property('soldPercent');",
									"            pm.expect(position.takeProfit).to.have.property('moonBagActivated');",
									"            pm.expect(position.takeProfit).to.have.property('transactionIds');",
									"        });",
									"        ",
									"        pm.test('First position has DCA fields', function () {",
									"            const position = response[0];",
									"            pm.expect(position).to.have.property('dca');",
									"            pm.expect(position.dca).to.have.property('count');",
									"            pm.expect(position.dca).to.have.property('totalInvestedSol');",
									"        });",
									"    }",
									"} else {",
									"    pm.test('Get positions failed', function () {",
									"        pm.response.to.have.status(200);",
									"    });",
									"}"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": [
								{
									"key": "token",
									"value": "{{access_token}}",
									"type": "string"
								}
							]
						},
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{base_url}}/api/v1/agents/{{agent_id}}/positions?walletAddress={{wallet_address}}",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"api",
								"v1",
								"agents",
								"{{agent_id}}",
								"positions"
							],
							"query": [
								{
									"key": "walletAddress",
									"value": "{{wallet_address}}",
									"description": "Optional - Filter by wallet address",
									"disabled": true
								}
							]
						},
						"description": "Get all open positions for an agent with enriched data including current prices, profit/loss calculations, and transaction details. Response is organized into logical groups for better readability.\n\n## Headers\n\n```\nAuthorization: Bearer <access_token>\n```\n\n## Path Parameters\n\n- `id`: Agent ID (UUID)\n\n## Query Parameters\n\n- `walletAddress` (optional): Wallet Address (UUID) - filter positions by specific wallet\n\n## Response\n\nArray of position objects with enriched data, organized into logical groups:\n\n```json\n[\n    {\n        \"id\": \"uuid\",\n        \"agentId\": \"uuid\",\n        \"walletAddress\": \"uuid\",\n        \"tokenAddress\": \"So11111111111111111111111111111111111111112\",\n        \"tokenSymbol\": \"SOL\",\n        \"purchase\": {\n            \"priceNative\": 0.000001987,\n            \"priceUsd\": 0.0002789,\n            \"amount\": 1000000,\n            \"transaction\": {\n                \"id\": \"uuid\",\n                \"hash\": \"5KJp...abc\",\n                \"time\": \"2025-01-27T12:00:00.000Z\"\n            }\n        },\n        \"current\": {\n            \"priceNative\": 0.000002284,\n            \"priceUsd\": 0.0003206,\n            \"valueNative\": 2.284,\n            \"valueUsd\": 320.60\n        },\n        \"profitLoss\": {\n            \"native\": 0.297,\n            \"usd\": 41.70,\n            \"percent\": 14.95,\n            \"priceChangePercent\": 14.95\n        },\n        \"stopLoss\": {\n            \"percentage\": -32.0,\n            \"peakPrice\": 0.000002500\n        },\n        \"createdAt\": \"2025-01-27T12:00:00.000Z\",\n        \"updatedAt\": \"2025-01-27T12:05:00.000Z\"\n    }\n]\n```\n\n## Response Structure\n\n### Basic Identification\n- `id` (string): Position ID (UUID)\n- `agentId` (string): Agent ID (UUID)\n- `walletAddress` (string): Wallet Address (UUID)\n- `tokenAddress` (string): Token address\n- `tokenSymbol` (string): Token symbol\n\n### Purchase Information (`purchase`)\n- `priceNative` (number): Purchase price per token in SOL (native currency)\n- `priceUsd` (number): Purchase price per token in USD (estimated at purchase time)\n- `amount` (number): Amount of tokens purchased\n- `transaction` (object): Purchase transaction details\n  - `id` (string): Transaction ID\n  - `hash` (string | null): On-chain transaction hash\n  - `time` (string): Transaction timestamp\n\n### Current Market Data (`current`)\n- `priceNative` (number): Current price per token in SOL (from price feed)\n- `priceUsd` (number): Current price per token in USD\n- `valueNative` (number): Current position value in SOL\n- `valueUsd` (number): Current position value in USD\n\n### Profit/Loss Metrics (`profitLoss`)\n- `native` (number): Profit/loss in SOL\n- `usd` (number): Profit/loss in USD\n- `percent` (number): Profit/loss percentage\n- `priceChangePercent` (number): Price change percentage from entry\n\n### Stop Loss Information (`stopLoss`)\n- `percentage` (number | null): Current stop loss percentage\n- `peakPrice` (number | null): Highest price reached (for trailing stop loss)\n\n### Timestamps\n- `createdAt` (string): Position creation timestamp\n- `updatedAt` (string): Last update timestamp\n\n## Error Responses\n\n- `400`: Invalid agent ID format or invalid wallet address format\n- `401`: Unauthorized (missing or invalid token)\n- `404`: Agent not found or wallet not found (if walletAddress provided)\n- `500`: Internal server error\n\n## Notes\n\n- Requires authentication (access token in Authorization header)\n- Only returns positions for agents owned by the authenticated user\n- Positions are sorted by creation date (newest first)\n- Current prices are fetched from DexScreener API in real-time\n- If price fetch fails for a token, purchase price is used as fallback\n- USD calculations use current SOL/USD price (approximation)\n- All prices in `purchase` and `current` groups use \"Native\" suffix to indicate SOL (native currency)\n- If walletAddress is provided, returns only positions for that wallet\n- If walletAddress is not provided, returns all positions for the agent across all wallets\n- Use `{{agent_id}}` environment variable or provide a valid UUID\n- Use `{{wallet_address}}` environment variable for wallet filtering (optional)"
					},
					"response": []
				},
				{
					"name": "Close Agent Position",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"// Check if access token exists",
									"if (!pm.environment.get('access_token')) {",
									"    throw new Error('Access token not found. Please login first.');",
									"}",
									"",
									"// Check if agent_id exists",
									"if (!pm.environment.get('agent_id')) {",
									"    throw new Error('Agent ID not found. Please create an agent first.');",
									"}",
									"",
									"// Check if position_id exists",
									"if (!pm.environment.get('position_id')) {",
									"    throw new Error('Position ID not found. Please execute a trade first to create a position.');",
									"}"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"if (pm.response.code === 200) {",
									"    const response = pm.response.json();",
									"    ",
									"    pm.test('Status code is 200', function () {",
									"        pm.response.to.have.status(200);",
									"    });",
									"    ",
									"    pm.test('Response has success flag', function () {",
									"        pm.expect(response).to.have.property('success');",
									"        pm.expect(response.success).to.be.true;",
									"    });",
									"    ",
									"    pm.test('Response has transactionId', function () {",
									"        pm.expect(response).to.have.property('transactionId');",
									"    });",
									"    ",
									"    pm.test('Response has historicalSwapId', function () {",
									"        pm.expect(response).to.have.property('historicalSwapId');",
									"    });",
									"    ",
									"    pm.test('Response has positionId', function () {",
									"        pm.expect(response).to.have.property('positionId');",
									"    });",
									"    ",
									"    pm.test('Response has inputAmount', function () {",
									"        pm.expect(response).to.have.property('inputAmount');",
									"        pm.expect(response.inputAmount).to.be.a('number');",
									"    });",
									"    ",
									"    pm.test('Response has outputAmount', function () {",
									"        pm.expect(response).to.have.property('outputAmount');",
									"        pm.expect(response.outputAmount).to.be.a('number');",
									"    });",
									"    ",
									"    pm.test('Response has salePrice', function () {",
									"        pm.expect(response).to.have.property('salePrice');",
									"        pm.expect(response.salePrice).to.be.a('number');",
									"    });",
									"    ",
									"    pm.test('Response has profitLossSol', function () {",
									"        pm.expect(response).to.have.property('profitLossSol');",
									"        pm.expect(response.profitLossSol).to.be.a('number');",
									"    });",
									"    ",
									"    pm.test('Response has profitLossUsd', function () {",
									"        pm.expect(response).to.have.property('profitLossUsd');",
									"        pm.expect(response.profitLossUsd).to.be.a('number');",
									"    });",
									"    ",
									"    pm.test('Response has changePercent', function () {",
									"        pm.expect(response).to.have.property('changePercent');",
									"        pm.expect(response.changePercent).to.be.a('number');",
									"    });",
									"    ",
									"    // Clear position_id from environment after successful closure",
									"    pm.environment.unset('position_id');",
									"} else {",
									"    pm.test('Close position failed', function () {",
									"        pm.response.to.have.status(200);",
									"    });",
									"}"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": [
								{
									"key": "token",
									"value": "{{access_token}}",
									"type": "string"
								}
							]
						},
						"method": "POST",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json",
								"type": "text"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n    \"reason\": \"manual\"\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{base_url}}/api/v1/agents/{{agent_id}}/positions/{{position_id}}/close",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"api",
								"v1",
								"agents",
								"{{agent_id}}",
								"positions",
								"{{position_id}}",
								"close"
							]
						},
						"description": "Close a position by executing a sell trade. This endpoint orchestrates the complete sale execution flow including swap execution, balance updates, historical swap record creation, and position closure.\n\n## Headers\n\n```\nAuthorization: Bearer <access_token>\nContent-Type: application/json\n```\n\n## Path Parameters\n\n- `id`: Agent ID (UUID)\n- `positionId`: Position ID (UUID)\n\n## Request Body\n\n```json\n{\n    \"reason\": \"manual\" | \"stop_loss\"\n}\n```\n\n## Parameters\n\n- `reason` (optional): Reason for closure - \"manual\" (default) or \"stop_loss\"\n\n## Response\n\n```json\n{\n    \"success\": true,\n    \"transactionId\": \"uuid\",\n    \"historicalSwapId\": \"uuid\",\n    \"positionId\": \"uuid\",\n    \"inputAmount\": 1000000,\n    \"outputAmount\": 0.5,\n    \"salePrice\": 0.0000005,\n    \"profitLossSol\": 0.05,\n    \"profitLossUsd\": 7.50,\n    \"changePercent\": 10.0,\n    \"transactionHash\": null\n}\n```\n\n## Response Fields\n\n- `success` (boolean): Indicates if the sale executed successfully\n- `transactionId` (string): UUID of the created sale transaction record\n- `historicalSwapId` (string): UUID of the created historical swap record\n- `positionId` (string): UUID of the closed position\n- `inputAmount` (number): Amount of tokens sold\n- `outputAmount` (number): Amount of SOL received\n- `salePrice` (number): Sale price per token in SOL\n- `profitLossSol` (number): Profit/loss in SOL\n- `profitLossUsd` (number): Profit/loss in USD\n- `changePercent` (number): Percentage change from purchase price\n- `transactionHash` (string | null): On-chain transaction hash (null for simulation mode)\n\n## Error Responses\n\n- `400`: Invalid input (missing positionId, invalid reason, position not found, position mismatch)\n- `401`: Unauthorized (missing or invalid token)\n- `403`: Forbidden (position does not belong to agent or agent does not belong to user)\n- `404`: Agent not found, position not found\n- `500`: Internal server error\n\n## Notes\n\n- Requires authentication (access token in Authorization header)\n- Agent must belong to the authenticated user\n- Position must belong to the specified agent\n- Wallet must be unlocked before executing the sale\n- Agent must have sufficient token balance for the position\n- For simulation mode, no actual on-chain transaction is executed (transactionHash will be null)\n- For live mode, actual swap is executed on-chain and transactionHash is recorded\n- Position is automatically removed from the database after successful closure\n- Historical swap record is created with purchase and sale transaction references\n- Position ID is automatically cleared from the environment after successful closure\n- Use `{{agent_id}}` and `{{position_id}}` environment variables or provide valid UUIDs\n- The position will be removed from the live positions list via WebSocket after closure"
					},
					"response": []
				},
				{
					"name": "Get Take-Profit Summary",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"// Check if access token exists",
									"if (!pm.environment.get('access_token')) {",
									"    throw new Error('Access token not found. Please login first.');",
									"}",
									"",
									"// Check if agent_id exists",
									"if (!pm.environment.get('agent_id')) {",
									"    throw new Error('Agent ID not found. Please create an agent first.');",
									"}"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"if (pm.response.code === 200) {",
									"    const response = pm.response.json();",
									"    ",
									"    pm.test('Status code is 200', function () {",
									"        pm.response.to.have.status(200);",
									"    });",
									"    ",
									"    pm.test('Response has totalPositions', function () {",
									"        pm.expect(response).to.have.property('totalPositions');",
									"        pm.expect(response.totalPositions).to.be.a('number');",
									"    });",
									"    ",
									"    pm.test('Response has positionsWithTakeProfitHit', function () {",
									"        pm.expect(response).to.have.property('positionsWithTakeProfitHit');",
									"        pm.expect(response.positionsWithTakeProfitHit).to.be.a('number');",
									"    });",
									"    ",
									"    pm.test('Response has activeMoonBags', function () {",
									"        pm.expect(response).to.have.property('activeMoonBags');",
									"        pm.expect(response.activeMoonBags).to.be.a('number');",
									"    });",
									"    ",
									"    pm.test('Response has totalLevelsHit', function () {",
									"        pm.expect(response).to.have.property('totalLevelsHit');",
									"        pm.expect(response.totalLevelsHit).to.be.a('number');",
									"    });",
									"} else {",
									"    pm.test('Get take-profit summary failed', function () {",
									"        pm.response.to.have.status(200);",
									"    });",
									"}"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": [
								{
									"key": "token",
									"value": "{{access_token}}",
									"type": "string"
								}
							]
						},
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{base_url}}/api/v1/agent-positions/{{agent_id}}/take-profit-summary?includePositions=false",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"api",
								"v1",
								"agent-positions",
								"{{agent_id}}",
								"take-profit-summary"
							],
							"query": [
								{
									"key": "includePositions",
									"value": "false",
									"description": "Set to 'true' to include detailed position breakdown"
								}
							]
						},
						"description": "Get a summary of take-profit activity for an agent. Returns aggregate statistics about take-profit executions across all positions.\n\n## Headers\n\n```\nAuthorization: Bearer <access_token>\n```\n\n## Path Parameters\n\n- `agentId`: Agent ID (UUID)\n\n## Query Parameters\n\n- `includePositions` (optional): Set to 'true' to include detailed position breakdown\n\n## Response\n\n```json\n{\n    \"totalPositions\": 5,\n    \"positionsWithTakeProfitHit\": 2,\n    \"activeMoonBags\": 1,\n    \"totalLevelsHit\": 4,\n    \"positions\": [\n        {\n            \"id\": \"uuid\",\n            \"tokenSymbol\": \"BONK\",\n            \"levelsHit\": 2,\n            \"remainingPercent\": 50.0,\n            \"moonBagActivated\": false,\n            \"lastTakeProfitTime\": \"2025-01-27T12:00:00.000Z\"\n        }\n    ]\n}\n```\n\n## Response Fields\n\n- `totalPositions` (number): Total number of open positions for the agent\n- `positionsWithTakeProfitHit` (number): Number of positions with at least one take-profit level executed\n- `activeMoonBags` (number): Number of positions with moon bags activated\n- `totalLevelsHit` (number): Total take-profit levels hit across all positions\n- `positions` (array, optional): Detailed breakdown per position (only if includePositions=true)\n  - `id` (string): Position ID\n  - `tokenSymbol` (string): Token symbol\n  - `levelsHit` (number): Number of take-profit levels hit for this position\n  - `remainingPercent` (number): Percentage of original position remaining\n  - `moonBagActivated` (boolean): Whether moon bag has been activated\n  - `lastTakeProfitTime` (string | null): Last take-profit execution timestamp\n\n## Error Responses\n\n- `400`: Invalid agent ID format\n- `401`: Unauthorized (missing or invalid token)\n- `404`: Agent not found\n- `500`: Internal server error\n\n## Notes\n\n- Requires authentication (access token in Authorization header)\n- Only returns data for agents owned by the authenticated user\n- Take-profit and DCA are mutually exclusive - only one can be enabled at a time\n- Moon bags are portions of positions retained indefinitely after reaching a profit threshold\n- Use `{{agent_id}}` environment variable or provide a valid UUID"
					},
					"response": []
				}
			],
			"description": "Agent position management endpoints for retrieving open positions, closing positions, and viewing take-profit activity. All endpoints require authentication and users can only access positions for their own agents."
		},
		{
			"name": "Agent Balances",
			"item": [
				{
					"name": "Create Agent Balance",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"// Check if access token exists",
									"if (!pm.environment.get('access_token')) {",
									"    throw new Error('Access token not found. Please login first.');",
									"}",
									"",
									"// Check if agent_id exists",
									"if (!pm.environment.get('agent_id')) {",
									"    throw new Error('Agent ID not found. Please create an agent first.');",
									"}"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"if (pm.response.code === 201) {",
									"    const response = pm.response.json();",
									"    ",
									"    // Store balance ID in environment",
									"    pm.environment.set('balance_id', response.id);",
									"    ",
									"    pm.test('Status code is 201', function () {",
									"        pm.response.to.have.status(201);",
									"    });",
									"    ",
									"    pm.test('Response has balance id', function () {",
									"        pm.expect(response).to.have.property('id');",
									"    });",
									"    ",
									"    pm.test('Response has agentId', function () {",
									"        pm.expect(response).to.have.property('agentId');",
									"    });",
									"    ",
									"    pm.test('Response has tokenAddress', function () {",
									"        pm.expect(response).to.have.property('tokenAddress');",
									"    });",
									"    ",
									"    pm.test('Response has tokenSymbol', function () {",
									"        pm.expect(response).to.have.property('tokenSymbol');",
									"    });",
									"    ",
									"    pm.test('Response has balance', function () {",
									"        pm.expect(response).to.have.property('balance');",
									"    });",
									"    ",
									"    pm.test('Response has lastUpdated', function () {",
									"        pm.expect(response).to.have.property('lastUpdated');",
									"    });",
									"} else {",
									"    pm.test('Request failed', function () {",
									"        pm.response.to.have.status(201);",
									"    });",
									"}"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": [
								{
									"key": "token",
									"value": "{{access_token}}",
									"type": "string"
								}
							]
						},
						"method": "POST",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json",
								"type": "text"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n    \"agentId\": \"{{agent_id}}\",\n    \"walletAddress\": \"{{wallet_address}}\",\n    \"tokenAddress\": \"So11111111111111111111111111111111111111112\",\n    \"tokenSymbol\": \"SOL\",\n    \"balance\": \"1000000000\"\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{base_url}}/api/v1/agent-balances",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"api",
								"v1",
								"agent-balances"
							]
						},
						"description": "Create a new agent balance.\n\n## Headers\n\n```\nAuthorization: Bearer <access_token>\n```\n\n## Request Body\n\n```json\n{\n    \"agentId\": \"uuid\",\n    \"walletAddress\": \"uuid (optional - will be determined from agent's trading mode if not provided)\",\n    \"tokenAddress\": \"So11111111111111111111111111111111111111112\",\n    \"tokenSymbol\": \"SOL\",\n    \"balance\": \"1000000000\"\n}\n```\n\n## Parameters\n\n- `agentId` (required): Agent ID (UUID)\n- `walletAddress` (optional): Wallet Address (UUID) - if not provided, will be determined from agent's trading mode\n- `tokenAddress` (required): Token address (max 255 characters)\n- `tokenSymbol` (required): Token symbol (max 20 characters)\n- `balance` (required): Token balance as a string (for arbitrary precision)\n\n## Response\n\n```json\n{\n    \"id\": \"uuid\",\n    \"agentId\": \"uuid\",\n    \"walletAddress\": \"uuid\",\n    \"tokenAddress\": \"So11111111111111111111111111111111111111112\",\n    \"tokenSymbol\": \"SOL\",\n    \"balance\": \"1000000000\",\n    \"lastUpdated\": \"2025-01-27T00:00:00.000Z\"\n}\n```\n\n## Error Responses\n\n- `400`: Invalid input (missing fields, invalid format, invalid balance format, no wallet found for agent)\n- `401`: Unauthorized (missing or invalid token)\n- `404`: Agent not found\n- `409`: Balance already exists for this wallet and token\n- `500`: Internal server error\n\n## Notes\n\n- Requires authentication (access token in Authorization header)\n- Agent must belong to the authenticated user\n- Balances are now per-wallet (not per-agent)\n- If walletAddress is not provided, it will be determined from the agent's current trading mode\n- WalletId must belong to the specified agent if provided\n- Balance must be a valid number string\n- Token address and symbol are validated for length\n- Balance ID is automatically stored in the environment for use in other requests\n- Use `{{agent_id}}` environment variable or provide a valid UUID"
					},
					"response": []
				},
				{
					"name": "List Agent Balances",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"// Check if access token exists",
									"if (!pm.environment.get('access_token')) {",
									"    throw new Error('Access token not found. Please login first.');",
									"}",
									"",
									"// Check if agent_id exists",
									"if (!pm.environment.get('agent_id')) {",
									"    throw new Error('Agent ID not found. Please create an agent first.');",
									"}"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test('Status code is 200', function () {",
									"    pm.response.to.have.status(200);",
									"});",
									"",
									"pm.test('Response is an array', function () {",
									"    const response = pm.response.json();",
									"    pm.expect(response).to.be.an('array');",
									"});",
									"",
									"pm.test('Each balance has required fields', function () {",
									"    const balances = pm.response.json();",
									"    if (balances.length > 0) {",
									"        const balance = balances[0];",
									"        pm.expect(balance).to.have.property('id');",
									"        pm.expect(balance).to.have.property('agentId');",
									"        pm.expect(balance).to.have.property('walletAddress');",
									"        pm.expect(balance).to.have.property('tokenAddress');",
									"        pm.expect(balance).to.have.property('tokenSymbol');",
									"        pm.expect(balance).to.have.property('balance');",
									"        pm.expect(balance).to.have.property('lastUpdated');",
									"    }",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": [
								{
									"key": "token",
									"value": "{{access_token}}",
									"type": "string"
								}
							]
						},
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{base_url}}/api/v1/agent-balances?agentId={{agent_id}}",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"api",
								"v1",
								"agent-balances"
							],
							"query": [
								{
									"key": "agentId",
									"value": "{{agent_id}}",
									"description": "Agent ID (required)",
									"disabled": false
								},
								{
									"key": "walletAddress",
									"value": "{{wallet_address}}",
									"description": "Wallet Address (optional - filter by wallet)",
									"disabled": true
								}
							]
						},
						"description": "Get all balances for an agent.\n\n## Headers\n\n```\nAuthorization: Bearer <access_token>\n```\n\n## Query Parameters\n\n- `agentId` (required): Agent ID (UUID)\n- `walletAddress` (optional): Wallet Address (UUID) - filter balances by wallet\n\n## Response\n\n```json\n[\n    {\n        \"id\": \"uuid\",\n        \"agentId\": \"uuid\",\n        \"walletAddress\": \"uuid\",\n        \"tokenAddress\": \"So11111111111111111111111111111111111111112\",\n        \"tokenSymbol\": \"SOL\",\n        \"balance\": \"1000000000\",\n        \"lastUpdated\": \"2025-01-27T00:00:00.000Z\"\n    }\n]\n```\n\n## Error Responses\n\n- `400`: Invalid agent ID format or missing agentId parameter\n- `401`: Unauthorized (missing or invalid token)\n- `404`: Agent not found\n- `500`: Internal server error\n\n## Notes\n\n- Requires authentication (access token in Authorization header)\n- Agent must belong to the authenticated user\n- Balances are now per-wallet (not per-agent)\n- If walletAddress is provided, returns only balances for that wallet\n- If walletAddress is not provided, returns all balances for the agent across all wallets\n- Balances are ordered by lastUpdated (most recent first)\n- Returns an empty array if the agent has no balances\n- Use `{{agent_id}}` environment variable or provide a valid UUID"
					},
					"response": []
				},
				{
					"name": "Get Agent Balance",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"// Check if access token exists",
									"if (!pm.environment.get('access_token')) {",
									"    throw new Error('Access token not found. Please login first.');",
									"}",
									"",
									"// Check if balance_id exists",
									"if (!pm.environment.get('balance_id')) {",
									"    throw new Error('Balance ID not found. Please create an agent balance first.');",
									"}"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test('Status code is 200', function () {",
									"    pm.response.to.have.status(200);",
									"});",
									"",
									"pm.test('Response has balance id', function () {",
									"    const response = pm.response.json();",
									"    pm.expect(response).to.have.property('id');",
									"});",
									"",
									"pm.test('Response has agentId', function () {",
									"    const response = pm.response.json();",
									"    pm.expect(response).to.have.property('agentId');",
									"});",
									"",
									"pm.test('Response has tokenAddress', function () {",
									"    const response = pm.response.json();",
									"    pm.expect(response).to.have.property('tokenAddress');",
									"});",
									"",
									"pm.test('Response has tokenSymbol', function () {",
									"    const response = pm.response.json();",
									"    pm.expect(response).to.have.property('tokenSymbol');",
									"});",
									"",
									"pm.test('Response has balance', function () {",
									"    const response = pm.response.json();",
									"    pm.expect(response).to.have.property('balance');",
									"});",
									"",
									"pm.test('Response has lastUpdated', function () {",
									"    const response = pm.response.json();",
									"    pm.expect(response).to.have.property('lastUpdated');",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": [
								{
									"key": "token",
									"value": "{{access_token}}",
									"type": "string"
								}
							]
						},
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{base_url}}/api/v1/agent-balances/{{balance_id}}",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"api",
								"v1",
								"agent-balances",
								"{{balance_id}}"
							]
						},
						"description": "Get a specific agent balance by ID.\n\n## Headers\n\n```\nAuthorization: Bearer <access_token>\n```\n\n## Path Parameters\n\n- `id`: Balance ID (UUID)\n\n## Response\n\n```json\n{\n    \"id\": \"uuid\",\n    \"agentId\": \"uuid\",\n    \"walletAddress\": \"uuid\",\n    \"tokenAddress\": \"So11111111111111111111111111111111111111112\",\n    \"tokenSymbol\": \"SOL\",\n    \"balance\": \"1000000000\",\n    \"lastUpdated\": \"2025-01-27T00:00:00.000Z\"\n}\n```\n\n## Error Responses\n\n- `400`: Invalid balance ID format\n- `401`: Unauthorized (missing or invalid token)\n- `404`: Balance not found\n- `500`: Internal server error\n\n## Notes\n\n- Requires authentication (access token in Authorization header)\n- Balance must belong to an agent owned by the authenticated user\n- Returns 404 if the balance doesn't exist or doesn't belong to the user's agent\n- Balances are now per-wallet (not per-agent)\n- Use `{{balance_id}}` environment variable or provide a valid UUID"
					},
					"response": []
				},
				{
					"name": "Update Agent Balance",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"// Check if access token exists",
									"if (!pm.environment.get('access_token')) {",
									"    throw new Error('Access token not found. Please login first.');",
									"}",
									"",
									"// Check if balance_id exists",
									"if (!pm.environment.get('balance_id')) {",
									"    throw new Error('Balance ID not found. Please create an agent balance first.');",
									"}"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test('Status code is 200', function () {",
									"    pm.response.to.have.status(200);",
									"});",
									"",
									"pm.test('Response has balance id', function () {",
									"    const response = pm.response.json();",
									"    pm.expect(response).to.have.property('id');",
									"});",
									"",
									"pm.test('Response has updated balance', function () {",
									"    const response = pm.response.json();",
									"    pm.expect(response).to.have.property('balance');",
									"});",
									"",
									"pm.test('Response has lastUpdated', function () {",
									"    const response = pm.response.json();",
									"    pm.expect(response).to.have.property('lastUpdated');",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": [
								{
									"key": "token",
									"value": "{{access_token}}",
									"type": "string"
								}
							]
						},
						"method": "PUT",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json",
								"type": "text"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n    \"balance\": \"2000000000\",\n    \"tokenSymbol\": \"SOL\"\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{base_url}}/api/v1/agent-balances/{{balance_id}}",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"api",
								"v1",
								"agent-balances",
								"{{balance_id}}"
							]
						},
						"description": "Update an existing agent balance.\n\n## Headers\n\n```\nAuthorization: Bearer <access_token>\n```\n\n## Path Parameters\n\n- `id`: Balance ID (UUID)\n\n## Request Body\n\n```json\n{\n    \"balance\": \"2000000000\",\n    \"tokenSymbol\": \"SOL\"\n}\n```\n\n## Parameters\n\n- `balance` (optional): Updated token balance as a string\n- `tokenSymbol` (optional): Updated token symbol (max 20 characters)\n\n## Response\n\n```json\n{\n    \"id\": \"uuid\",\n    \"agentId\": \"uuid\",\n    \"walletAddress\": \"uuid\",\n    \"tokenAddress\": \"So11111111111111111111111111111111111111112\",\n    \"tokenSymbol\": \"SOL\",\n    \"balance\": \"2000000000\",\n    \"lastUpdated\": \"2025-01-27T00:00:01.000Z\"\n}\n```\n\n## Error Responses\n\n- `400`: Invalid input (invalid ID format, invalid balance format, at least one field required)\n- `401`: Unauthorized (missing or invalid token)\n- `404`: Balance not found\n- `500`: Internal server error\n\n## Notes\n\n- Requires authentication (access token in Authorization header)\n- Balance must belong to an agent owned by the authenticated user\n- At least one field (balance or tokenSymbol) must be provided\n- Balance must be a valid number string\n- Balances are now per-wallet (not per-agent)\n- Returns 404 if the balance doesn't exist or doesn't belong to the user's agent\n- Use `{{balance_id}}` environment variable or provide a valid UUID"
					},
					"response": []
				},
				{
					"name": "Delete Agent Balance",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"// Check if access token exists",
									"if (!pm.environment.get('access_token')) {",
									"    throw new Error('Access token not found. Please login first.');",
									"}",
									"",
									"// Check if balance_id exists",
									"if (!pm.environment.get('balance_id')) {",
									"    throw new Error('Balance ID not found. Please create an agent balance first.');",
									"}"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"if (pm.response.code === 200) {",
									"    // Clear balance_id from environment after deletion",
									"    pm.environment.unset('balance_id');",
									"    ",
									"    pm.test('Status code is 200', function () {",
									"        pm.response.to.have.status(200);",
									"    });",
									"    ",
									"    pm.test('Response indicates success', function () {",
									"        const response = pm.response.json();",
									"        pm.expect(response).to.have.property('success');",
									"        pm.expect(response.success).to.be.true;",
									"    });",
									"} else {",
									"    pm.test('Delete failed', function () {",
									"        pm.response.to.have.status(200);",
									"    });",
									"}"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": [
								{
									"key": "token",
									"value": "{{access_token}}",
									"type": "string"
								}
							]
						},
						"method": "DELETE",
						"header": [],
						"url": {
							"raw": "{{base_url}}/api/v1/agent-balances/{{balance_id}}",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"api",
								"v1",
								"agent-balances",
								"{{balance_id}}"
							]
						},
						"description": "Delete an agent balance.\n\n## Headers\n\n```\nAuthorization: Bearer <access_token>\n```\n\n## Path Parameters\n\n- `id`: Balance ID (UUID)\n\n## Response\n\n```json\n{\n    \"success\": true,\n    \"message\": \"Balance deleted successfully\"\n}\n```\n\n## Error Responses\n\n- `400`: Invalid balance ID format\n- `401`: Unauthorized (missing or invalid token)\n- `404`: Balance not found\n- `500`: Internal server error\n\n## Notes\n\n- Requires authentication (access token in Authorization header)\n- Balance must belong to an agent owned by the authenticated user\n- Returns 404 if the balance doesn't exist or doesn't belong to the user's agent\n- Balance ID is automatically cleared from the environment after successful deletion\n- Use `{{balance_id}}` environment variable or provide a valid UUID"
					},
					"response": []
				}
			],
			"description": "Agent balance management endpoints for creating, reading, updating, and deleting agent token balances. All endpoints require authentication and users can only access balances for their own agents."
		},
		{
			"name": "Trading Signals",
			"item": [
				{
					"name": "Create Trading Signal",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"// Require either JWT (access_token) or API key",
									"if (!pm.environment.get('access_token') && !pm.environment.get('api_key')) {",
									"    throw new Error('Set access_token (Login first) or api_key in environment.');",
									"}"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"if (pm.response.code === 201) {",
									"    const response = pm.response.json();",
									"    ",
									"    // Store signal ID in environment",
									"    pm.environment.set('signal_id', response.id);",
									"    ",
									"    pm.test('Status code is 201', function () {",
									"        pm.response.to.have.status(201);",
									"    });",
									"    ",
									"    pm.test('Response has signal id', function () {",
									"        pm.expect(response).to.have.property('id');",
									"    });",
									"    ",
									"    pm.test('Response has tokenAddress', function () {",
									"        pm.expect(response).to.have.property('tokenAddress');",
									"    });",
									"    ",
									"    pm.test('Response has signalType', function () {",
									"        pm.expect(response).to.have.property('signalType');",
									"    });",
									"    ",
									"    pm.test('Response has signalStrength', function () {",
									"        pm.expect(response).to.have.property('signalStrength');",
									"        pm.expect(response.signalStrength).to.be.at.least(1);",
									"        pm.expect(response.signalStrength).to.be.at.most(5);",
									"    });",
									"} else {",
									"    pm.test('Create failed', function () {",
									"        pm.response.to.have.status(201);",
									"    });",
									"}"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": [
								{
									"key": "token",
									"value": "{{access_token}}",
									"type": "string"
								}
							]
						},
						"method": "POST",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json",
								"type": "text"
							},
							{
								"key": "X-API-Key",
								"value": "{{api_key}}",
								"type": "text",
								"description": "Optional. Use API key (with signals scope) instead of Bearer token. Set api_key in environment."
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n    \"tokenAddress\": \"So11111111111111111111111111111111111111112\",\n    \"symbol\": \"SOL\",\n    \"signalType\": \"Hypersurge\",\n    \"activationReason\": \"Strong bullish momentum detected\",\n    \"signalStrength\": 4,\n    \"source\": \"Nexgent AI\"\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{base_url}}/api/v1/trading-signals",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"api",
								"v1",
								"trading-signals"
							]
						},
						"description": "Create a new trading signal.\n\n## Authentication (use one)\n\n- **JWT:** Authorization tab  Bearer Token  `{{access_token}}` (login first)\n- **API key:** Headers  X-API-Key = `{{api_key}}` (set api_key in environment; key must have `signals` scope)\n\n## Headers\n\n```\nContent-Type: application/json\nX-API-Key: nex_xxxxx   (optional, if using API key instead of JWT)\n```\n\n## Request Body\n\n```json\n{\n    \"tokenAddress\": \"So11111111111111111111111111111111111111112\",\n    \"symbol\": \"SOL\",\n    \"signalType\": \"Hypersurge\",\n    \"activationReason\": \"Strong bullish momentum detected\",\n    \"signalStrength\": 4,\n    \"source\": \"Nexgent AI\"\n}\n```\n\n## Field Requirements\n\n- `tokenAddress`: Required, string, max 255 characters\n- `symbol`: Optional, string or null, max 50 characters (e.g., \"SOL\", \"USDC\")\n- `signalType`: Required, string, max 50 characters (e.g., \"Hypersurge\", \"SELL\", \"HOLD\")\n- `activationReason`: Optional, string or null\n- `signalStrength`: Required, integer between 1 and 5\n- `source`: Optional, string or null, max 100 characters (e.g., \"Nexgent AI\", \"DexScreener\", \"Custom API\")\n\n## Response\n\n```json\n{\n    \"id\": \"uuid\",\n    \"createdAt\": \"2025-01-27T00:00:00.000Z\",\n    \"updatedAt\": \"2025-01-27T00:00:00.000Z\",\n    \"tokenAddress\": \"So11111111111111111111111111111111111111112\",\n    \"symbol\": \"SOL\",\n    \"signalType\": \"Hypersurge\",\n    \"activationReason\": \"Strong bullish momentum detected\",\n    \"signalStrength\": 4,\n    \"source\": \"Nexgent AI\"\n}\n```\n\n## Error Responses\n\n- `400`: Invalid input (missing required fields, invalid signal strength, etc.)\n- `401`: Unauthorized (missing or invalid token)\n- `500`: Internal server error"
					},
					"response": []
				},
				{
					"name": "List Trading Signals",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"// Check if access token exists",
									"if (!pm.environment.get('access_token')) {",
									"    throw new Error('Access token not found. Please login first.');",
									"}"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"if (pm.response.code === 200) {",
									"    const response = pm.response.json();",
									"    ",
									"    pm.test('Status code is 200', function () {",
									"        pm.response.to.have.status(200);",
									"    });",
									"    ",
									"    pm.test('Response is an array', function () {",
									"        pm.expect(response).to.be.an('array');",
									"    });",
									"    ",
									"    if (response.length > 0) {",
									"        pm.test('First signal has required fields', function () {",
									"            pm.expect(response[0]).to.have.property('id');",
									"            pm.expect(response[0]).to.have.property('tokenAddress');",
									"            pm.expect(response[0]).to.have.property('signalType');",
									"            pm.expect(response[0]).to.have.property('signalStrength');",
									"        });",
									"        ",
									"        // Store first signal ID if not already set",
									"        if (!pm.environment.get('signal_id')) {",
									"            pm.environment.set('signal_id', response[0].id);",
									"        }",
									"    }",
									"} else {",
									"    pm.test('List failed', function () {",
									"        pm.response.to.have.status(200);",
									"    });",
									"}"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": [
								{
									"key": "token",
									"value": "{{access_token}}",
									"type": "string"
								}
							]
						},
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{base_url}}/api/v1/trading-signals?tokenAddress=So11111111111111111111111111111111111111112&signalType=Hypersurge&limit=100&offset=0",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"api",
								"v1",
								"trading-signals"
							],
							"query": [
								{
									"key": "tokenAddress",
									"value": "So11111111111111111111111111111111111111112",
									"description": "Filter by token address",
									"disabled": true
								},
								{
									"key": "signalType",
									"value": "BUY",
									"description": "Filter by signal type",
									"disabled": true
								},
								{
									"key": "startDate",
									"value": "",
									"description": "Filter by start date (ISO string)",
									"disabled": true
								},
								{
									"key": "endDate",
									"value": "",
									"description": "Filter by end date (ISO string)",
									"disabled": true
								},
								{
									"key": "limit",
									"value": "100",
									"description": "Maximum number of results (default: 100, max: 1000)",
									"disabled": true
								},
								{
									"key": "offset",
									"value": "0",
									"description": "Number of results to skip (default: 0)",
									"disabled": true
								}
							]
						},
						"description": "List trading signals with optional filtering.\n\n## Headers\n\n```\nAuthorization: Bearer <access_token>\n```\n\n## Query Parameters\n\n- `tokenAddress` (optional): Filter by token address\n- `signalType` (optional): Filter by signal type (e.g., \"Hypersurge\", \"SELL\", \"HOLD\")\n- `startDate` (optional): Filter by start date (ISO string, e.g., \"2025-01-01T00:00:00.000Z\")\n- `endDate` (optional): Filter by end date (ISO string, e.g., \"2025-01-31T23:59:59.999Z\")\n- `limit` (optional): Maximum number of results (default: 100, max: 1000)\n- `offset` (optional): Number of results to skip (default: 0)\n\n## Response\n\n```json\n[\n    {\n        \"id\": \"uuid\",\n        \"createdAt\": \"2025-01-27T00:00:00.000Z\",\n        \"updatedAt\": \"2025-01-27T00:00:00.000Z\",\n        \"tokenAddress\": \"So11111111111111111111111111111111111111112\",\n        \"symbol\": \"SOL\",\n        \"signalType\": \"Hypersurge\",\n        \"activationReason\": \"Strong bullish momentum detected\",\n        \"signalStrength\": 4,\n        \"source\": \"Nexgent AI\"\n    }\n]\n```\n\n## Error Responses\n\n- `400`: Invalid query parameters (invalid date format, invalid limit/offset)\n- `401`: Unauthorized (missing or invalid token)\n- `500`: Internal server error\n\n## Notes\n\n- Results are ordered by creation date (most recent first)\n- All query parameters are optional\n- Use `startDate` and `endDate` together to filter by date range"
					},
					"response": []
				},
				{
					"name": "Get Trading Signal",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"// Check if access token exists",
									"if (!pm.environment.get('access_token')) {",
									"    throw new Error('Access token not found. Please login first.');",
									"}"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"if (pm.response.code === 200) {",
									"    const response = pm.response.json();",
									"    ",
									"    pm.test('Status code is 200', function () {",
									"        pm.response.to.have.status(200);",
									"    });",
									"    ",
									"    pm.test('Response has signal id', function () {",
									"        pm.expect(response).to.have.property('id');",
									"    });",
									"    ",
									"    pm.test('Response has tokenAddress', function () {",
									"        pm.expect(response).to.have.property('tokenAddress');",
									"    });",
									"    ",
									"    pm.test('Response has signalType', function () {",
									"        pm.expect(response).to.have.property('signalType');",
									"    });",
									"    ",
									"    pm.test('Response has signalStrength', function () {",
									"        pm.expect(response).to.have.property('signalStrength');",
									"        pm.expect(response.signalStrength).to.be.at.least(1);",
									"        pm.expect(response.signalStrength).to.be.at.most(5);",
									"    });",
									"} else {",
									"    pm.test('Get failed', function () {",
									"        pm.response.to.have.status(200);",
									"    });",
									"}"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": [
								{
									"key": "token",
									"value": "{{access_token}}",
									"type": "string"
								}
							]
						},
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{base_url}}/api/v1/trading-signals/{{signal_id}}",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"api",
								"v1",
								"trading-signals",
								"{{signal_id}}"
							]
						},
						"description": "Get a trading signal by ID.\n\n## Headers\n\n```\nAuthorization: Bearer <access_token>\n```\n\n## Path Parameters\n\n- `id`: Signal ID (UUID)\n\n## Response\n\n```json\n{\n    \"id\": \"uuid\",\n    \"createdAt\": \"2025-01-27T00:00:00.000Z\",\n    \"updatedAt\": \"2025-01-27T00:00:00.000Z\",\n    \"tokenAddress\": \"So11111111111111111111111111111111111111112\",\n    \"symbol\": \"SOL\",\n    \"signalType\": \"Hypersurge\",\n    \"activationReason\": \"Strong bullish momentum detected\",\n    \"signalStrength\": 4,\n    \"source\": \"Nexgent AI\"\n}\n```\n\n## Error Responses\n\n- `400`: Invalid signal ID format\n- `401`: Unauthorized (missing or invalid token)\n- `404`: Signal not found\n- `500`: Internal server error\n\n## Notes\n\n- Requires authentication (access token in Authorization header)\n- Use `{{signal_id}}` environment variable or provide a valid UUID"
					},
					"response": []
				},
				{
					"name": "Update Trading Signal",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"// Check if access token exists",
									"if (!pm.environment.get('access_token')) {",
									"    throw new Error('Access token not found. Please login first.');",
									"}",
									"",
									"// Check if signal_id exists",
									"if (!pm.environment.get('signal_id')) {",
									"    throw new Error('Signal ID not found. Please create a trading signal first.');",
									"}"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"if (pm.response.code === 200) {",
									"    const response = pm.response.json();",
									"    ",
									"    pm.test('Status code is 200', function () {",
									"        pm.response.to.have.status(200);",
									"    });",
									"    ",
									"    pm.test('Response has signal id', function () {",
									"        pm.expect(response).to.have.property('id');",
									"    });",
									"    ",
									"    pm.test('Response has updatedAt', function () {",
									"        pm.expect(response).to.have.property('updatedAt');",
									"    });",
									"} else {",
									"    pm.test('Update failed', function () {",
									"        pm.response.to.have.status(200);",
									"    });",
									"}"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": [
								{
									"key": "token",
									"value": "{{access_token}}",
									"type": "string"
								}
							]
						},
						"method": "PUT",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json",
								"type": "text"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n    \"symbol\": \"SOL\",\n    \"signalStrength\": 5,\n    \"activationReason\": \"Updated: Very strong bullish momentum\",\n    \"source\": \"DexScreener\"\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{base_url}}/api/v1/trading-signals/{{signal_id}}",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"api",
								"v1",
								"trading-signals",
								"{{signal_id}}"
							]
						},
						"description": "Update an existing trading signal.\n\n## Headers\n\n```\nAuthorization: Bearer <access_token>\nContent-Type: application/json\n```\n\n## Path Parameters\n\n- `id`: Signal ID (UUID)\n\n## Request Body\n\nAll fields are optional. Only include fields you want to update.\n\n```json\n{\n    \"tokenAddress\": \"So11111111111111111111111111111111111111112\",\n    \"symbol\": \"SOL\",\n    \"signalType\": \"SELL\",\n    \"activationReason\": \"Updated: Strong bearish momentum detected\",\n    \"signalStrength\": 3,\n    \"source\": \"Custom API\"\n}\n```\n\n## Field Requirements\n\n- `tokenAddress`: Optional, string, max 255 characters\n- `symbol`: Optional, string or null, max 50 characters\n- `signalType`: Optional, string, max 50 characters\n- `activationReason`: Optional, string or null\n- `signalStrength`: Optional, integer between 1 and 5\n- `source`: Optional, string or null, max 100 characters (e.g., \"Nexgent AI\", \"DexScreener\", \"Custom API\")\n\n## Response\n\n```json\n{\n    \"id\": \"uuid\",\n    \"createdAt\": \"2025-01-27T00:00:00.000Z\",\n    \"updatedAt\": \"2025-01-27T01:00:00.000Z\",\n    \"tokenAddress\": \"So11111111111111111111111111111111111111112\",\n    \"symbol\": \"SOL\",\n    \"signalType\": \"SELL\",\n    \"activationReason\": \"Updated: Strong bearish momentum detected\",\n    \"signalStrength\": 3,\n    \"source\": \"Custom API\"\n}\n```\n\n## Error Responses\n\n- `400`: Invalid input (invalid signal strength, invalid field values)\n- `401`: Unauthorized (missing or invalid token)\n- `404`: Signal not found\n- `500`: Internal server error\n\n## Notes\n\n- Requires authentication (access token in Authorization header)\n- Only include fields you want to update in the request body\n- `updatedAt` is automatically updated when any field changes\n- Use `{{signal_id}}` environment variable or provide a valid UUID"
					},
					"response": []
				},
				{
					"name": "Delete Trading Signal",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"// Check if access token exists",
									"if (!pm.environment.get('access_token')) {",
									"    throw new Error('Access token not found. Please login first.');",
									"}",
									"",
									"// Check if signal_id exists",
									"if (!pm.environment.get('signal_id')) {",
									"    throw new Error('Signal ID not found. Please create a trading signal first.');",
									"}"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"if (pm.response.code === 204) {",
									"    pm.test('Status code is 204', function () {",
									"        pm.response.to.have.status(204);",
									"    });",
									"    ",
									"    // Clear signal ID from environment after successful deletion",
									"    pm.environment.unset('signal_id');",
									"} else {",
									"    pm.test('Delete failed', function () {",
									"        pm.response.to.have.status(204);",
									"    });",
									"}"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": [
								{
									"key": "token",
									"value": "{{access_token}}",
									"type": "string"
								}
							]
						},
						"method": "DELETE",
						"header": [],
						"url": {
							"raw": "{{base_url}}/api/v1/trading-signals/{{signal_id}}",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"api",
								"v1",
								"trading-signals",
								"{{signal_id}}"
							]
						},
						"description": "Delete a trading signal.\n\n## Headers\n\n```\nAuthorization: Bearer <access_token>\n```\n\n## Path Parameters\n\n- `id`: Signal ID (UUID)\n\n## Response\n\n204 No Content (empty body)\n\n## Error Responses\n\n- `400`: Invalid signal ID format\n- `401`: Unauthorized (missing or invalid token)\n- `404`: Signal not found\n- `500`: Internal server error\n\n## Notes\n\n- Requires authentication (access token in Authorization header)\n- Returns 204 No Content on success\n- Signal ID is automatically cleared from the environment after successful deletion\n- Use `{{signal_id}}` environment variable or provide a valid UUID"
					},
					"response": []
				},
				{
					"name": "Delete All Trading Signals",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"// Check if access token exists",
									"if (!pm.environment.get('access_token')) {",
									"    throw new Error('Access token not found. Please login first.');",
									"}"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"if (pm.response.code === 200) {",
									"    const response = pm.response.json();",
									"    ",
									"    pm.test('Status code is 200', function () {",
									"        pm.response.to.have.status(200);",
									"    });",
									"    ",
									"    pm.test('Response has deletedCount', function () {",
									"        pm.expect(response).to.have.property('deletedCount');",
									"    });",
									"    ",
									"    pm.test('Response has success message', function () {",
									"        pm.expect(response.message).to.equal('All trading signals deleted successfully');",
									"    });",
									"    ",
									"    console.log('Deleted ' + response.deletedCount + ' trading signals');",
									"} else if (pm.response.code === 400) {",
									"    pm.test('Missing confirmation parameter', function () {",
									"        const response = pm.response.json();",
									"        pm.expect(response.error).to.equal('Confirmation required');",
									"    });",
									"} else {",
									"    pm.test('Delete all failed', function () {",
									"        pm.response.to.have.status(200);",
									"    });",
									"}"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": [
								{
									"key": "token",
									"value": "{{access_token}}",
									"type": "string"
								}
							]
						},
						"method": "DELETE",
						"header": [],
						"url": {
							"raw": "{{base_url}}/api/v1/trading-signals/all?confirm=true",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"api",
								"v1",
								"trading-signals",
								"all"
							],
							"query": [
								{
									"key": "confirm",
									"value": "true",
									"description": "Required confirmation parameter. Must be 'true' to delete all signals."
								}
							]
						},
						"description": "Delete ALL trading signals from the database.\n\n##  WARNING\n\nThis is a destructive operation that cannot be undone. All trading signals will be permanently deleted.\n\n## Headers\n\n```\nAuthorization: Bearer <access_token>\n```\n\n## Query Parameters\n\n- `confirm`: Must be `true` to confirm deletion (required safety check)\n\n## Response\n\n```json\n{\n    \"message\": \"All trading signals deleted successfully\",\n    \"deletedCount\": 42\n}\n```\n\n## Error Responses\n\n- `400`: Missing or invalid confirmation parameter\n- `401`: Unauthorized (missing or invalid token)\n- `500`: Internal server error\n\n## Notes\n\n- Requires authentication (access token in Authorization header)\n- The `confirm=true` query parameter is required as a safety check\n- Returns the count of deleted signals"
					},
					"response": []
				}
			],
			"description": "Trading signal management endpoints for creating, reading, updating, and deleting trading signals. Trading signals are system-wide signals that can trigger agent transactions. All endpoints require authentication."
		},
		{
			"name": "Agent Transactions",
			"item": [
				{
					"name": "Create Agent Transaction",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"// Check if access token exists",
									"if (!pm.environment.get('access_token')) {",
									"    throw new Error('Access token not found. Please login first.');",
									"}",
									"",
									"// Check if agent_id exists",
									"if (!pm.environment.get('agent_id')) {",
									"    throw new Error('Agent ID not found. Please create an agent first.');",
									"}"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"if (pm.response.code === 201) {",
									"    const response = pm.response.json();",
									"    ",
									"    // Store transaction ID in environment",
									"    pm.environment.set('transaction_id', response.id);",
									"    ",
									"    pm.test('Status code is 201', function () {",
									"        pm.response.to.have.status(201);",
									"    });",
									"    ",
									"    pm.test('Response has transaction id', function () {",
									"        pm.expect(response).to.have.property('id');",
									"    });",
									"    ",
									"    pm.test('Response has agentId', function () {",
									"        pm.expect(response).to.have.property('agentId');",
									"    });",
									"    ",
									"    pm.test('Response has transactionType', function () {",
									"        pm.expect(response).to.have.property('transactionType');",
									"    });",
									"} else {",
									"    pm.test('Create failed', function () {",
									"        pm.response.to.have.status(201);",
									"    });",
									"}"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": [
								{
									"key": "token",
									"value": "{{access_token}}",
									"type": "string"
								}
							]
						},
						"method": "POST",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json",
								"type": "text"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n    \"agentId\": \"{{agent_id}}\",\n    \"walletAddress\": \"{{wallet_address}}\",\n    \"transactionType\": \"SWAP\",\n    \"transactionValueUsd\": \"100.50\",\n    \"transactionTime\": \"2025-01-27T12:00:00.000Z\",\n    \"signalId\": \"{{signal_id}}\",\n    \"inputMint\": \"So11111111111111111111111111111111111111112\",\n    \"inputSymbol\": \"SOL\",\n    \"inputPrice\": \"100.00\",\n    \"outputMint\": \"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v\",\n    \"outputSymbol\": \"USDC\",\n    \"outputAmount\": \"100.50\",\n    \"outputPrice\": \"1.00\",\n    \"fees\": \"0.50\",\n    \"slippage\": \"0.10\",\n    \"priceImpact\": \"0.05\",\n    \"isDca\": false\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{base_url}}/api/v1/agent-transactions",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"api",
								"v1",
								"agent-transactions"
							]
						},
						"description": "Create a new agent transaction.\n\n## Headers\n\n```\nAuthorization: Bearer <access_token>\nContent-Type: application/json\n```\n\n## Request Body\n\n```json\n{\n    \"agentId\": \"uuid\",\n    \"walletAddress\": \"uuid (optional - will be determined from agent's trading mode if not provided)\",\n    \"transactionType\": \"SWAP\",\n    \"transactionValueUsd\": \"100.50\",\n    \"transactionTime\": \"2025-01-27T12:00:00.000Z\",\n    \"signalId\": \"uuid (optional - links transaction to a trading signal)\",\n    \"destinationAddress\": \"optional\",\n    \"fees\": \"0.50\",\n    \"routes\": {},\n    \"inputMint\": \"So11111111111111111111111111111111111111112\",\n    \"inputSymbol\": \"SOL\",\n    \"inputPrice\": \"100.00\",\n    \"outputMint\": \"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v\",\n    \"outputSymbol\": \"USDC\",\n    \"outputAmount\": \"100.50\",\n    \"outputPrice\": \"1.00\",\n    \"slippage\": \"0.10\",\n    \"priceImpact\": \"0.05\",\n    \"isDca\": false\n}\n```\n\n## Transaction Types\n\n- `DEPOSIT`: Deposit funds\n- `WITHDRAWAL`: Withdraw funds\n- `SWAP`: Token swap\n- `BURN`: Token burn\n\n## Response\n\n```json\n{\n    \"id\": \"uuid\",\n    \"agentId\": \"uuid\",\n    \"walletAddress\": \"uuid | null\",\n    \"transactionType\": \"SWAP\",\n    \"transactionValueUsd\": \"100.50\",\n    \"transactionTime\": \"2025-01-27T12:00:00.000Z\",\n    ...\n}\n```\n\n## Error Responses\n\n- `400`: Invalid input (wallet does not belong to agent)\n- `401`: Unauthorized\n- `403`: Forbidden (not your agent)\n- `404`: Agent or signal not found\n- `500`: Internal server error\n\n## Notes\n\n- If walletAddress is not provided, it will be determined from the agent's current trading mode\n- WalletId must belong to the specified agent if provided"
					},
					"response": []
				},
				{
					"name": "List Agent Transactions",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"// Check if access token exists",
									"if (!pm.environment.get('access_token')) {",
									"    throw new Error('Access token not found. Please login first.');",
									"}",
									"",
									"// Check if agent_id exists",
									"if (!pm.environment.get('agent_id')) {",
									"    throw new Error('Agent ID not found. Please create an agent first.');",
									"}"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"if (pm.response.code === 200) {",
									"    const response = pm.response.json();",
									"    ",
									"    pm.test('Status code is 200', function () {",
									"        pm.response.to.have.status(200);",
									"    });",
									"    ",
									"    pm.test('Response is an array', function () {",
									"        pm.expect(response).to.be.an('array');",
									"    });",
									"    ",
									"    if (response.length > 0) {",
									"        pm.test('First transaction has required fields', function () {",
									"            pm.expect(response[0]).to.have.property('id');",
									"            pm.expect(response[0]).to.have.property('agentId');",
									"            pm.expect(response[0]).to.have.property('transactionType');",
									"        });",
									"        ",
									"        // Store first transaction ID if not already set",
									"        if (!pm.environment.get('transaction_id')) {",
									"            pm.environment.set('transaction_id', response[0].id);",
									"        }",
									"    }",
									"} else {",
									"    pm.test('List failed', function () {",
									"        pm.response.to.have.status(200);",
									"    });",
									"}"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": [
								{
									"key": "token",
									"value": "{{access_token}}",
									"type": "string"
								}
							]
						},
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{base_url}}/api/v1/agent-transactions?agentId={{agent_id}}&transactionType=SWAP&limit=100&offset=0",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"api",
								"v1",
								"agent-transactions"
							],
							"query": [
								{
									"key": "agentId",
									"value": "{{agent_id}}",
									"description": "Required - Filter by agent ID",
									"disabled": false
								},
								{
									"key": "walletAddress",
									"value": "{{wallet_address}}",
									"description": "Optional - Filter by wallet address",
									"disabled": true
								},
								{
									"key": "transactionType",
									"value": "SWAP",
									"description": "Filter by transaction type (DEPOSIT, SWAP, BURN)",
									"disabled": true
								},
								{
									"key": "startTime",
									"value": "",
									"description": "Filter by start time (ISO string)",
									"disabled": true
								},
								{
									"key": "endTime",
									"value": "",
									"description": "Filter by end time (ISO string)",
									"disabled": true
								},
								{
									"key": "signalId",
									"value": "",
									"description": "Filter by signal ID",
									"disabled": true
								},
								{
									"key": "isDca",
									"value": "",
									"description": "Filter by DCA flag (true/false)",
									"disabled": true
								},
								{
									"key": "limit",
									"value": "100",
									"description": "Maximum number of results (default: 100, max: 1000)",
									"disabled": true
								},
								{
									"key": "offset",
									"value": "0",
									"description": "Number of results to skip (default: 0)",
									"disabled": true
								}
							]
						},
						"description": "List agent transactions with optional filtering.\n\n## Headers\n\n```\nAuthorization: Bearer <access_token>\n```\n\n## Query Parameters\n\n- `agentId` (required): Filter by agent ID\n- `walletAddress` (optional): Filter by wallet address\n- `transactionType` (optional): Filter by type (DEPOSIT, SWAP, BURN)\n- `startTime` (optional): Filter by start time (ISO string)\n- `endTime` (optional): Filter by end time (ISO string)\n- `signalId` (optional): Filter by signal ID\n- `isDca` (optional): Filter by DCA flag (\"true\" or \"false\")\n- `limit` (optional): Maximum number of results (default: 100, max: 1000)\n- `offset` (optional): Number of results to skip (default: 0)\n\n## Response\n\nArray of transaction objects. Each transaction includes a `walletAddress` field (nullable).\n\n## Error Responses\n\n- `400`: Invalid query parameters\n- `401`: Unauthorized\n- `403`: Forbidden (not your agent)\n- `404`: Agent not found\n- `500`: Internal server error\n\n## Notes\n\n- Transactions can be filtered by walletAddress to show only transactions for a specific wallet\n- If walletAddress is not provided, returns all transactions for the agent across all wallets"
					},
					"response": []
				},
				{
					"name": "Get Agent Transaction",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"// Check if access token exists",
									"if (!pm.environment.get('access_token')) {",
									"    throw new Error('Access token not found. Please login first.');",
									"}"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"if (pm.response.code === 200) {",
									"    const response = pm.response.json();",
									"    ",
									"    pm.test('Status code is 200', function () {",
									"        pm.response.to.have.status(200);",
									"    });",
									"    ",
									"    pm.test('Response has transaction id', function () {",
									"        pm.expect(response).to.have.property('id');",
									"    });",
									"    ",
									"    pm.test('Response has agentId', function () {",
									"        pm.expect(response).to.have.property('agentId');",
									"    });",
									"} else {",
									"    pm.test('Get failed', function () {",
									"        pm.response.to.have.status(200);",
									"    });",
									"}"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": [
								{
									"key": "token",
									"value": "{{access_token}}",
									"type": "string"
								}
							]
						},
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{base_url}}/api/v1/agent-transactions/{{transaction_id}}",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"api",
								"v1",
								"agent-transactions",
								"{{transaction_id}}"
							]
						},
						"description": "Get an agent transaction by ID.\n\n## Headers\n\n```\nAuthorization: Bearer <access_token>\n```\n\n## Path Parameters\n\n- `id`: Transaction ID (UUID)\n\n## Response\n\nTransaction object. Includes `walletAddress` field (nullable).\n\n## Error Responses\n\n- `400`: Invalid transaction ID format\n- `401`: Unauthorized\n- `403`: Forbidden (not your agent)\n- `404`: Transaction not found\n- `500`: Internal server error\n\n## Notes\n\n- Transaction includes walletAddress field which may be null for older transactions"
					},
					"response": []
				},
				{
					"name": "Update Agent Transaction",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"// Check if access token exists",
									"if (!pm.environment.get('access_token')) {",
									"    throw new Error('Access token not found. Please login first.');",
									"}",
									"",
									"// Check if transaction_id exists",
									"if (!pm.environment.get('transaction_id')) {",
									"    throw new Error('Transaction ID not found. Please create a transaction first.');",
									"}"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"if (pm.response.code === 200) {",
									"    const response = pm.response.json();",
									"    ",
									"    pm.test('Status code is 200', function () {",
									"        pm.response.to.have.status(200);",
									"    });",
									"    ",
									"    pm.test('Response has updatedAt', function () {",
									"        pm.expect(response).to.have.property('updatedAt');",
									"    });",
									"} else {",
									"    pm.test('Update failed', function () {",
									"        pm.response.to.have.status(200);",
									"    });",
									"}"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": [
								{
									"key": "token",
									"value": "{{access_token}}",
									"type": "string"
								}
							]
						},
						"method": "PUT",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json",
								"type": "text"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n    \"fees\": \"0.75\",\n    \"slippage\": \"0.15\"\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{base_url}}/api/v1/agent-transactions/{{transaction_id}}",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"api",
								"v1",
								"agent-transactions",
								"{{transaction_id}}"
							]
						},
						"description": "Update an existing agent transaction.\n\n## Headers\n\n```\nAuthorization: Bearer <access_token>\nContent-Type: application/json\n```\n\n## Path Parameters\n\n- `id`: Transaction ID (UUID)\n\n## Request Body\n\nAll fields are optional. Only include fields you want to update.\n\n## Response\n\nUpdated transaction object\n\n## Error Responses\n\n- `400`: Invalid input\n- `401`: Unauthorized\n- `403`: Forbidden (not your agent)\n- `404`: Transaction or signal not found\n- `500`: Internal server error"
					},
					"response": []
				},
				{
					"name": "Delete Agent Transaction",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"// Check if access token exists",
									"if (!pm.environment.get('access_token')) {",
									"    throw new Error('Access token not found. Please login first.');",
									"}",
									"",
									"// Check if transaction_id exists",
									"if (!pm.environment.get('transaction_id')) {",
									"    throw new Error('Transaction ID not found. Please create a transaction first.');",
									"}"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"if (pm.response.code === 204) {",
									"    pm.test('Status code is 204', function () {",
									"        pm.response.to.have.status(204);",
									"    });",
									"    ",
									"    // Clear transaction ID from environment after successful deletion",
									"    pm.environment.unset('transaction_id');",
									"} else {",
									"    pm.test('Delete failed', function () {",
									"        pm.response.to.have.status(204);",
									"    });",
									"}"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": [
								{
									"key": "token",
									"value": "{{access_token}}",
									"type": "string"
								}
							]
						},
						"method": "DELETE",
						"header": [],
						"url": {
							"raw": "{{base_url}}/api/v1/agent-transactions/{{transaction_id}}",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"api",
								"v1",
								"agent-transactions",
								"{{transaction_id}}"
							]
						},
						"description": "Delete an agent transaction.\n\n## Headers\n\n```\nAuthorization: Bearer <access_token>\n```\n\n## Path Parameters\n\n- `id`: Transaction ID (UUID)\n\n## Response\n\n204 No Content (empty body)\n\n## Error Responses\n\n- `400`: Invalid transaction ID format\n- `401`: Unauthorized\n- `403`: Forbidden (not your agent)\n- `404`: Transaction not found\n- `500`: Internal server error"
					},
					"response": []
				}
			],
			"description": "Agent transaction management endpoints for creating, reading, updating, and deleting agent transactions. All endpoints require authentication and users can only access transactions for their own agents."
		},
		{
			"name": "Agent Historical Swaps",
			"item": [
				{
					"name": "Create Agent Historical Swap",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"// Check if access token exists",
									"if (!pm.environment.get('access_token')) {",
									"    throw new Error('Access token not found. Please login first.');",
									"}",
									"",
									"// Check if agent_id exists",
									"if (!pm.environment.get('agent_id')) {",
									"    throw new Error('Agent ID not found. Please create an agent first.');",
									"}"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"if (pm.response.code === 201) {",
									"    const response = pm.response.json();",
									"    ",
									"    // Store swap ID in environment",
									"    pm.environment.set('swap_id', response.id);",
									"    ",
									"    pm.test('Status code is 201', function () {",
									"        pm.response.to.have.status(201);",
									"    });",
									"    ",
									"    pm.test('Response has swap id', function () {",
									"        pm.expect(response).to.have.property('id');",
									"    });",
									"    ",
									"    pm.test('Response has agentId', function () {",
									"        pm.expect(response).to.have.property('agentId');",
									"    });",
									"    ",
									"    pm.test('Response has profitLossUsd', function () {",
									"        pm.expect(response).to.have.property('profitLossUsd');",
									"    });",
									"} else {",
									"    pm.test('Create failed', function () {",
									"        pm.response.to.have.status(201);",
									"    });",
									"}"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": [
								{
									"key": "token",
									"value": "{{access_token}}",
									"type": "string"
								}
							]
						},
						"method": "POST",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json",
								"type": "text"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n    \"agentId\": \"{{agent_id}}\",\n    \"walletAddress\": \"{{wallet_address}}\",\n    \"tokenAddress\": \"So11111111111111111111111111111111111111112\",\n    \"tokenSymbol\": \"SOL\",\n    \"amount\": \"1.5\",\n    \"purchasePrice\": \"100.00\",\n    \"salePrice\": \"110.00\",\n    \"changePercent\": \"10.00\",\n    \"profitLossUsd\": \"15.00\",\n    \"profitLossSol\": \"0.15\",\n    \"purchaseTime\": \"2025-01-20T12:00:00.000Z\",\n    \"saleTime\": \"2025-01-27T12:00:00.000Z\",\n    \"purchaseTransactionId\": null,\n    \"saleTransactionId\": null,\n    \"signalId\": \"{{signal_id}}\"\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{base_url}}/api/v1/agent-historical-swaps",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"api",
								"v1",
								"agent-historical-swaps"
							]
						},
						"description": "Create a new agent historical swap record.\n\n## Headers\n\n```\nAuthorization: Bearer <access_token>\nContent-Type: application/json\n```\n\n## Request Body\n\n```json\n{\n    \"agentId\": \"uuid\",\n    \"walletAddress\": \"uuid (optional - will be determined from agent's trading mode if not provided)\",\n    \"tokenAddress\": \"So11111111111111111111111111111111111111112\",\n    \"tokenSymbol\": \"SOL\",\n    \"amount\": \"1.5\",\n    \"purchasePrice\": \"100.00\",\n    \"salePrice\": \"110.00\",\n    \"changePercent\": \"10.00\",\n    \"profitLossUsd\": \"15.00\",\n    \"profitLossSol\": \"0.15\",\n    \"purchaseTime\": \"2025-01-20T12:00:00.000Z\",\n    \"saleTime\": \"2025-01-27T12:00:00.000Z\",\n    \"purchaseTransactionId\": \"uuid (optional)\",\n    \"saleTransactionId\": \"uuid (optional)\",\n    \"signalId\": \"uuid (optional)\"\n}\n```\n\n## Field Requirements\n\n- All fields except `walletAddress`, `purchaseTransactionId`, `saleTransactionId`, and `signalId` are required\n- `saleTime` must be >= `purchaseTime`\n- `amount`, `purchasePrice`, `salePrice` must be positive\n- `changePercent` and `profitLossUsd`/`profitLossSol` can be negative (for losses)\n- If walletAddress is not provided, it will be determined from the agent's current trading mode\n- WalletId must belong to the specified agent if provided\n\n## Response\n\n```json\n{\n    \"id\": \"uuid\",\n    \"agentId\": \"uuid\",\n    \"walletAddress\": \"uuid | null\",\n    \"tokenAddress\": \"So11111111111111111111111111111111111111112\",\n    \"tokenSymbol\": \"SOL\",\n    \"amount\": \"1.5\",\n    \"purchasePrice\": \"100.00\",\n    \"salePrice\": \"110.00\",\n    \"changePercent\": \"10.00\",\n    \"profitLossUsd\": \"15.00\",\n    \"profitLossSol\": \"0.15\",\n    \"purchaseTime\": \"2025-01-20T12:00:00.000Z\",\n    \"saleTime\": \"2025-01-27T12:00:00.000Z\",\n    \"purchaseTransactionId\": null,\n    \"saleTransactionId\": null,\n    \"signalId\": \"uuid\",\n    \"createdAt\": \"2025-01-27T12:00:00.000Z\"\n}\n```\n\n## Error Responses\n\n- `400`: Invalid input (missing required fields, invalid dates, saleTime < purchaseTime, wallet does not belong to agent, etc.)\n- `401`: Unauthorized\n- `403`: Forbidden (not your agent)\n- `404`: Agent, transaction, or signal not found\n- `500`: Internal server error"
					},
					"response": []
				},
				{
					"name": "List Agent Historical Swaps",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"// Check if access token exists",
									"if (!pm.environment.get('access_token')) {",
									"    throw new Error('Access token not found. Please login first.');",
									"}",
									"",
									"// Check if agent_id exists",
									"if (!pm.environment.get('agent_id')) {",
									"    throw new Error('Agent ID not found. Please create an agent first.');",
									"}"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"if (pm.response.code === 200) {",
									"    const response = pm.response.json();",
									"    ",
									"    pm.test('Status code is 200', function () {",
									"        pm.response.to.have.status(200);",
									"    });",
									"    ",
									"    pm.test('Response is an array', function () {",
									"        pm.expect(response).to.be.an('array');",
									"    });",
									"    ",
									"    if (response.length > 0) {",
									"        pm.test('First swap has required fields', function () {",
									"            pm.expect(response[0]).to.have.property('id');",
									"            pm.expect(response[0]).to.have.property('agentId');",
									"            pm.expect(response[0]).to.have.property('tokenAddress');",
									"            pm.expect(response[0]).to.have.property('profitLossUsd');",
									"        });",
									"        ",
									"        // Store first swap ID if not already set",
									"        if (!pm.environment.get('swap_id')) {",
									"            pm.environment.set('swap_id', response[0].id);",
									"        }",
									"    }",
									"} else {",
									"    pm.test('List failed', function () {",
									"        pm.response.to.have.status(200);",
									"    });",
									"}"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": [
								{
									"key": "token",
									"value": "{{access_token}}",
									"type": "string"
								}
							]
						},
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{base_url}}/api/v1/agent-historical-swaps?agentId={{agent_id}}&tokenAddress=So11111111111111111111111111111111111111112&limit=100&offset=0",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"api",
								"v1",
								"agent-historical-swaps"
							],
							"query": [
								{
									"key": "agentId",
									"value": "{{agent_id}}",
									"description": "Required - Filter by agent ID",
									"disabled": false
								},
								{
									"key": "walletAddress",
									"value": "{{wallet_address}}",
									"description": "Optional - Filter by wallet address",
									"disabled": true
								},
								{
									"key": "tokenAddress",
									"value": "So11111111111111111111111111111111111111112",
									"description": "Filter by token address",
									"disabled": true
								},
								{
									"key": "tokenSymbol",
									"value": "",
									"description": "Filter by token symbol",
									"disabled": true
								},
								{
									"key": "startPurchaseTime",
									"value": "",
									"description": "Filter by start purchase time (ISO string)",
									"disabled": true
								},
								{
									"key": "endPurchaseTime",
									"value": "",
									"description": "Filter by end purchase time (ISO string)",
									"disabled": true
								},
								{
									"key": "startSaleTime",
									"value": "",
									"description": "Filter by start sale time (ISO string)",
									"disabled": true
								},
								{
									"key": "endSaleTime",
									"value": "",
									"description": "Filter by end sale time (ISO string)",
									"disabled": true
								},
								{
									"key": "signalId",
									"value": "",
									"description": "Filter by signal ID",
									"disabled": true
								},
								{
									"key": "purchaseTransactionId",
									"value": "",
									"description": "Filter by purchase transaction ID",
									"disabled": true
								},
								{
									"key": "saleTransactionId",
									"value": "",
									"description": "Filter by sale transaction ID",
									"disabled": true
								},
								{
									"key": "minProfitLossUsd",
									"value": "",
									"description": "Filter by minimum profit/loss USD",
									"disabled": true
								},
								{
									"key": "maxProfitLossUsd",
									"value": "",
									"description": "Filter by maximum profit/loss USD",
									"disabled": true
								},
								{
									"key": "limit",
									"value": "100",
									"description": "Maximum number of results (default: 100, max: 1000)",
									"disabled": true
								},
								{
									"key": "offset",
									"value": "0",
									"description": "Number of results to skip (default: 0)",
									"disabled": true
								}
							]
						},
						"description": "List agent historical swaps with optional filtering.\n\n## Headers\n\n```\nAuthorization: Bearer <access_token>\n```\n\n## Query Parameters\n\n- `agentId` (required): Filter by agent ID\n- `walletAddress` (optional): Filter by wallet address\n- `tokenAddress` (optional): Filter by token address\n- `tokenSymbol` (optional): Filter by token symbol\n- `startPurchaseTime` (optional): Filter by start purchase time (ISO string)\n- `endPurchaseTime` (optional): Filter by end purchase time (ISO string)\n- `startSaleTime` (optional): Filter by start sale time (ISO string)\n- `endSaleTime` (optional): Filter by end sale time (ISO string)\n- `signalId` (optional): Filter by signal ID\n- `purchaseTransactionId` (optional): Filter by purchase transaction ID\n- `saleTransactionId` (optional): Filter by sale transaction ID\n- `minProfitLossUsd` (optional): Filter by minimum profit/loss USD\n- `maxProfitLossUsd` (optional): Filter by maximum profit/loss USD\n- `limit` (optional): Maximum number of results (default: 100, max: 1000)\n- `offset` (optional): Number of results to skip (default: 0)\n\n## Response\n\nArray of swap objects, ordered by sale time (most recent first). Each swap includes a `walletAddress` field (nullable).\n\n## Error Responses\n\n- `400`: Invalid query parameters\n- `401`: Unauthorized\n- `403`: Forbidden (not your agent)\n- `404`: Agent not found\n- `500`: Internal server error\n\n## Notes\n\n- Swaps can be filtered by walletAddress to show only swaps for a specific wallet\n- If walletAddress is not provided, returns all swaps for the agent across all wallets"
					},
					"response": []
				},
				{
					"name": "Get Agent Historical Swap",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"// Check if access token exists",
									"if (!pm.environment.get('access_token')) {",
									"    throw new Error('Access token not found. Please login first.');",
									"}"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"if (pm.response.code === 200) {",
									"    const response = pm.response.json();",
									"    ",
									"    pm.test('Status code is 200', function () {",
									"        pm.response.to.have.status(200);",
									"    });",
									"    ",
									"    pm.test('Response has swap id', function () {",
									"        pm.expect(response).to.have.property('id');",
									"    });",
									"    ",
									"    pm.test('Response has agentId', function () {",
									"        pm.expect(response).to.have.property('agentId');",
									"    });",
									"    ",
									"    pm.test('Response has profitLossUsd', function () {",
									"        pm.expect(response).to.have.property('profitLossUsd');",
									"    });",
									"} else {",
									"    pm.test('Get failed', function () {",
									"        pm.response.to.have.status(200);",
									"    });",
									"}"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": [
								{
									"key": "token",
									"value": "{{access_token}}",
									"type": "string"
								}
							]
						},
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{base_url}}/api/v1/agent-historical-swaps/{{swap_id}}",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"api",
								"v1",
								"agent-historical-swaps",
								"{{swap_id}}"
							]
						},
						"description": "Get an agent historical swap by ID.\n\n## Headers\n\n```\nAuthorization: Bearer <access_token>\n```\n\n## Path Parameters\n\n- `id`: Swap ID (UUID)\n\n## Response\n\nSwap object with all fields. Includes `walletAddress` field (nullable).\n\n## Error Responses\n\n- `400`: Invalid swap ID format\n- `401`: Unauthorized\n- `403`: Forbidden (not your agent)\n- `404`: Swap not found\n- `500`: Internal server error\n\n## Notes\n\n- Swap includes walletAddress field which may be null for older swaps"
					},
					"response": []
				},
				{
					"name": "Update Agent Historical Swap",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"// Check if access token exists",
									"if (!pm.environment.get('access_token')) {",
									"    throw new Error('Access token not found. Please login first.');",
									"}",
									"",
									"// Check if swap_id exists",
									"if (!pm.environment.get('swap_id')) {",
									"    throw new Error('Swap ID not found. Please create a historical swap first.');",
									"}"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"if (pm.response.code === 200) {",
									"    const response = pm.response.json();",
									"    ",
									"    pm.test('Status code is 200', function () {",
									"        pm.response.to.have.status(200);",
									"    });",
									"    ",
									"    pm.test('Response has swap id', function () {",
									"        pm.expect(response).to.have.property('id');",
									"    });",
									"} else {",
									"    pm.test('Update failed', function () {",
									"        pm.response.to.have.status(200);",
									"    });",
									"}"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": [
								{
									"key": "token",
									"value": "{{access_token}}",
									"type": "string"
								}
							]
						},
						"method": "PUT",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json",
								"type": "text"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n    \"profitLossUsd\": \"20.00\",\n    \"changePercent\": \"12.00\"\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{base_url}}/api/v1/agent-historical-swaps/{{swap_id}}",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"api",
								"v1",
								"agent-historical-swaps",
								"{{swap_id}}"
							]
						},
						"description": "Update an existing agent historical swap.\n\n## Headers\n\n```\nAuthorization: Bearer <access_token>\nContent-Type: application/json\n```\n\n## Path Parameters\n\n- `id`: Swap ID (UUID)\n\n## Request Body\n\nAll fields are optional. Only include fields you want to update.\n\n## Response\n\nUpdated swap object\n\n## Error Responses\n\n- `400`: Invalid input (invalid dates, saleTime < purchaseTime, etc.)\n- `401`: Unauthorized\n- `403`: Forbidden (not your agent)\n- `404`: Swap, transaction, or signal not found\n- `500`: Internal server error"
					},
					"response": []
				},
				{
					"name": "Delete Agent Historical Swap",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"// Check if access token exists",
									"if (!pm.environment.get('access_token')) {",
									"    throw new Error('Access token not found. Please login first.');",
									"}",
									"",
									"// Check if swap_id exists",
									"if (!pm.environment.get('swap_id')) {",
									"    throw new Error('Swap ID not found. Please create a historical swap first.');",
									"}"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"if (pm.response.code === 204) {",
									"    pm.test('Status code is 204', function () {",
									"        pm.response.to.have.status(204);",
									"    });",
									"    ",
									"    // Clear swap ID from environment after successful deletion",
									"    pm.environment.unset('swap_id');",
									"} else {",
									"    pm.test('Delete failed', function () {",
									"        pm.response.to.have.status(204);",
									"    });",
									"}"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": [
								{
									"key": "token",
									"value": "{{access_token}}",
									"type": "string"
								}
							]
						},
						"method": "DELETE",
						"header": [],
						"url": {
							"raw": "{{base_url}}/api/v1/agent-historical-swaps/{{swap_id}}",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"api",
								"v1",
								"agent-historical-swaps",
								"{{swap_id}}"
							]
						},
						"description": "Delete an agent historical swap.\n\n## Headers\n\n```\nAuthorization: Bearer <access_token>\n```\n\n## Path Parameters\n\n- `id`: Swap ID (UUID)\n\n## Response\n\n204 No Content (empty body)\n\n## Error Responses\n\n- `400`: Invalid swap ID format\n- `401`: Unauthorized\n- `403`: Forbidden (not your agent)\n- `404`: Swap not found\n- `500`: Internal server error"
					},
					"response": []
				}
			],
			"description": "Agent historical swap management endpoints for creating, reading, updating, and deleting agent historical swap records. All endpoints require authentication and users can only access swaps for their own agents."
		},
		{
			"name": "Trades",
			"item": [
				{
					"name": "Execute Trade",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"// Check if access token exists",
									"if (!pm.environment.get('access_token')) {",
									"    throw new Error('Access token not found. Please login first.');",
									"}",
									"",
									"// Check if agent_id exists",
									"if (!pm.environment.get('agent_id')) {",
									"    throw new Error('Agent ID not found. Please create an agent first.');",
									"}"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"if (pm.response.code === 200) {",
									"    const response = pm.response.json();",
									"    ",
									"    // Store transaction ID in environment",
									"    if (response.transactionId) {",
									"        pm.environment.set('transaction_id', response.transactionId);",
									"    }",
									"    ",
									"    // Store position ID in environment if created",
									"    if (response.positionId) {",
									"        pm.environment.set('position_id', response.positionId);",
									"    }",
									"    ",
									"    pm.test('Status code is 200', function () {",
									"        pm.response.to.have.status(200);",
									"    });",
									"    ",
									"    pm.test('Response has success flag', function () {",
									"        pm.expect(response).to.have.property('success');",
									"        pm.expect(response.success).to.be.true;",
									"    });",
									"    ",
									"    pm.test('Response has transactionId', function () {",
									"        pm.expect(response).to.have.property('transactionId');",
									"    });",
									"    ",
									"    pm.test('Response has inputAmount', function () {",
									"        pm.expect(response).to.have.property('inputAmount');",
									"    });",
									"    ",
									"    pm.test('Response has outputAmount', function () {",
									"        pm.expect(response).to.have.property('outputAmount');",
									"    });",
									"    ",
									"    pm.test('Response has purchasePrice', function () {",
									"        pm.expect(response).to.have.property('purchasePrice');",
									"    });",
									"} else {",
									"    pm.test('Trade execution failed', function () {",
									"        pm.response.to.have.status(200);",
									"    });",
									"}"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": [
								{
									"key": "token",
									"value": "{{access_token}}",
									"type": "string"
								}
							]
						},
						"method": "POST",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json",
								"type": "text"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n    \"agentId\": \"{{agent_id}}\",\n    \"tokenAddress\": \"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v\",\n    \"tokenSymbol\": \"USDC\",\n    \"positionSize\": 0.5\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{base_url}}/api/v1/trades/execute",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"api",
								"v1",
								"trades",
								"execute"
							]
						},
						"description": "Execute a trade using the Trading Executor service. This endpoint orchestrates the complete trade execution flow including validation, position calculation, swap execution, balance updates, and position tracking.\n\n## Headers\n\n```\nAuthorization: Bearer <access_token>\nContent-Type: application/json\n```\n\n## Request Body\n\n```json\n{\n    \"agentId\": \"uuid\",\n    \"walletAddress\": \"uuid (optional - uses default wallet if not provided)\",\n    \"tokenAddress\": \"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v\",\n    \"tokenSymbol\": \"USDC (optional - will be fetched if not provided)\",\n    \"signalId\": 123 (optional - link to trading signal),\n    \"positionSize\": 0.5 (optional - override calculated position size in SOL)\n}\n```\n\n## Parameters\n\n- `agentId` (required): Agent ID (UUID)\n- `walletAddress` (optional): Wallet Address (UUID) - if not provided, uses default wallet for agent's trading mode\n- `tokenAddress` (required): Token address to purchase\n- `tokenSymbol` (optional): Token symbol - will be fetched from price feed if not provided\n- `signalId` (optional): Trading signal ID (number) - links transaction to a trading signal\n- `positionSize` (optional): Position size in SOL - overrides calculated position size based on agent balance\n\n## Response\n\n```json\n{\n    \"success\": true,\n    \"transactionId\": \"uuid\",\n    \"positionId\": \"uuid | null\",\n    \"inputAmount\": 0.5,\n    \"outputAmount\": 1234.567,\n    \"purchasePrice\": 0.000405,\n    \"transactionHash\": null,\n    \"stopLossInitialized\": true,\n    \"stopLossPercentage\": -32,\n    \"signalId\": null\n}\n```\n\n## Response Fields\n\n- `success` (boolean): Indicates if the trade executed successfully\n- `transactionId` (string): UUID of the created transaction record\n- `positionId` (string | null): UUID of the created position record (null if stop loss disabled)\n- `inputAmount` (number): Amount of SOL used for the trade\n- `outputAmount` (number): Amount of tokens received\n- `purchasePrice` (number): Price per token in SOL\n- `transactionHash` (string | null): On-chain transaction hash (null for simulation mode)\n- `stopLossInitialized` (boolean): Whether stop loss was initialized for the position\n- `stopLossPercentage` (number): Initial stop loss percentage\n- `signalId` (number | null): Linked trading signal ID if provided\n\n## Error Responses\n\n- `400`: Invalid input (missing agentId/tokenAddress, insufficient balance, position already exists, etc.)\n- `401`: Unauthorized (missing or invalid token)\n- `404`: Agent not found, wallet not found\n- `500`: Internal server error\n\n## Notes\n\n- Requires authentication (access token in Authorization header)\n- Agent must belong to the authenticated user\n- Agent must have a wallet matching its trading mode (simulation/live)\n- Wallet must be unlocked before executing trades\n- Agent must have sufficient SOL balance (accounts for minimum balance threshold)\n- Position size is automatically calculated based on agent balance and trading config (if not provided)\n- Cannot purchase a token if agent already has an open position for it\n- For simulation mode, no actual on-chain transaction is executed (transactionHash will be null)\n- For live mode, actual swap is executed on-chain and transactionHash is recorded\n- Stop loss is automatically initialized if enabled in trading config\n- Transaction ID and Position ID are automatically stored in the environment for use in other requests\n- Use `{{agent_id}}` environment variable or provide a valid UUID\n- Example token addresses:\n  - USDC: `EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v`\n  - BONK: `DezXAZ8z7PnrnRJjz3wXBoRgixCa6xjnB7YaB1pPB263`"
					},
					"response": []
				}
			],
			"description": "Trade execution endpoints for executing automated trades using the Trading Executor service. All endpoints require authentication and users can only execute trades for their own agents."
		},
		{
			"name": "Price Feeds",
			"item": [
				{
					"name": "Get SOL/USD Price",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"// Check if access token exists",
									"if (!pm.environment.get('access_token')) {",
									"    throw new Error('Access token not found. Please login first.');",
									"}"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"if (pm.response.code === 200) {",
									"    const response = pm.response.json();",
									"    ",
									"    pm.test('Status code is 200', function () {",
									"        pm.response.to.have.status(200);",
									"    });",
									"    ",
									"    pm.test('Response has price', function () {",
									"        pm.expect(response).to.have.property('price');",
									"        pm.expect(response.price).to.be.a('string');",
									"    });",
									"    ",
									"    pm.test('Response has lastUpdated', function () {",
									"        pm.expect(response).to.have.property('lastUpdated');",
									"    });",
									"    ",
									"    pm.test('Response has isStale', function () {",
									"        pm.expect(response).to.have.property('isStale');",
									"        pm.expect(response.isStale).to.be.a('boolean');",
									"    });",
									"    ",
									"    pm.test('Response has source', function () {",
									"        pm.expect(response).to.have.property('source');",
									"        pm.expect(response.source).to.equal('pyth');",
									"    });",
									"    ",
									"    pm.test('Price is a valid number', function () {",
									"        const price = parseFloat(response.price);",
									"        pm.expect(price).to.be.a('number');",
									"        pm.expect(price).to.be.above(0);",
									"    });",
									"} else if (pm.response.code === 503) {",
									"    pm.test('Price service not initialized', function () {",
									"        pm.response.to.have.status(503);",
									"    });",
									"} else {",
									"    pm.test('Get price failed', function () {",
									"        pm.response.to.have.status(200);",
									"    });",
									"}"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": [
								{
									"key": "token",
									"value": "{{access_token}}",
									"type": "string"
								}
							]
						},
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{base_url}}/api/v1/price-feeds/sol-usd",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"api",
								"v1",
								"price-feeds",
								"sol-usd"
							]
						},
						"description": "Get the current SOL/USD price from Pyth Network.\n\n## Headers\n\n```\nAuthorization: Bearer <access_token>\n```\n\n## Response\n\n```json\n{\n    \"price\": \"150.25000000\",\n    \"lastUpdated\": \"2025-01-27T12:00:00.000Z\",\n    \"isStale\": false,\n    \"source\": \"pyth\"\n}\n```\n\n## Response Fields\n\n- `price` (string): Current SOL/USD price with 8 decimal precision\n- `lastUpdated` (string | null): ISO timestamp of when the price was last updated, or null if not yet fetched\n- `isStale` (boolean): Indicates if the price is considered stale (older than 60 seconds)\n- `source` (string): Source of the price data (always \"pyth\")\n\n## Error Responses\n\n- `401`: Unauthorized (missing or invalid token)\n- `503`: Price service not initialized or price not yet fetched\n- `500`: Internal server error\n\n## Notes\n\n- Requires authentication (access token in Authorization header)\n- Price is fetched from Pyth Network and updated every 10 seconds\n- Price is stored in-memory on the backend server\n- If the price service hasn't fetched a price yet, returns 503 with an error message\n- The price is returned as a string to maintain precision (8 decimal places)\n- `isStale` flag helps clients determine if they should show a warning about potentially outdated data"
					},
					"response": []
				}
			],
			"description": "Price feed endpoints for fetching real-time cryptocurrency prices. Currently supports SOL/USD price from Pyth Network. All endpoints require authentication."
		},
		{
			"name": "Wallets",
			"item": [
				{
					"name": "Assign Wallet",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"// Check if access token exists",
									"if (!pm.environment.get('access_token')) {",
									"    throw new Error('Access token not found. Please login first.');",
									"}",
									"",
									"// Check if agent_id exists",
									"if (!pm.environment.get('agent_id')) {",
									"    throw new Error('Agent ID not found. Please create an agent first.');",
									"}"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"if (pm.response.code === 200 || pm.response.code === 201) {",
									"    const response = pm.response.json();",
									"    ",
									"    // Store wallet address in environment",
									"    pm.environment.set('wallet_address', response.walletAddress);",
									"    ",
									"    pm.test('Status code is 200 or 201', function () {",
									"        pm.expect([200, 201]).to.include(pm.response.code);",
									"    });",
									"    ",
									"    pm.test('Response has success flag', function () {",
									"        pm.expect(response).to.have.property('success');",
									"        pm.expect(response.success).to.be.true;",
									"    });",
									"    ",
									"    pm.test('Response has walletAddress', function () {",
									"        pm.expect(response).to.have.property('walletAddress');",
									"    });",
									"    ",
									"    pm.test('Response has walletType', function () {",
									"        pm.expect(response).to.have.property('walletType');",
									"        pm.expect(['simulation', 'live']).to.include(response.walletType);",
									"    });",
									"    ",
									"    pm.test('Response has network', function () {",
									"        pm.expect(response).to.have.property('network');",
									"        pm.expect(['testnet', 'mainnet']).to.include(response.network);",
									"    });",
									"} else {",
									"    pm.test('Assign wallet failed', function () {",
									"        pm.response.to.have.status([200, 201]);",
									"    });",
									"}"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": [
								{
									"key": "token",
									"value": "{{access_token}}",
									"type": "string"
								}
							]
						},
						"method": "POST",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json",
								"type": "text"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n    \"agentId\": \"{{agent_id}}\",\n    \"walletAddress\": \"YourWalletAddressHere\",\n    \"walletType\": \"live\"\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{base_url}}/api/v1/wallets/assign",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"api",
								"v1",
								"wallets",
								"assign"
							]
						},
						"description": "Assign a wallet from environment variables to an agent. For live wallets, the wallet must be loaded from environment variables (WALLET_1, WALLET_2, etc.). For simulation wallets, a new wallet is automatically generated.\n\n## Headers\n\n```\nAuthorization: Bearer <access_token>\n```\n\n## Request Body\n\n```json\n{\n    \"agentId\": \"uuid\",\n    \"walletAddress\": \"Base58 encoded Solana address\",\n    \"walletType\": \"simulation\" | \"live\"\n}\n```\n\n## Parameters\n\n- `agentId` (required): Agent ID (UUID)\n- `walletAddress` (required): Wallet address (Base58 encoded Solana address). For live wallets, must be loaded from environment variables.\n- `walletType` (required): Wallet type - 'simulation' for testnet or 'live' for mainnet\n\n## Response\n\n```json\n{\n    \"success\": true,\n    \"walletAddress\": \"Base58 encoded Solana address\",\n    \"walletType\": \"live\",\n    \"message\": \"Wallet assigned successfully\"\n}\n```\n\nNote: Network can be derived from walletType (simulation = testnet, live = mainnet)\n\n## Error Responses\n\n- `400`: Invalid input (missing fields, wallet not in environment for live wallets, invalid agent ID)\n- `401`: Unauthorized (missing or invalid token)\n- `404`: Agent not found\n- `500`: Internal server error\n\n## Notes\n\n- Requires authentication (access token in Authorization header)\n- Agent must belong to the authenticated user\n- For live wallets, the wallet address must be loaded from environment variables (WALLET_1, WALLET_2, etc.)\n- For simulation wallets, a new wallet is automatically generated if not provided\n- Each agent can have one simulation wallet and one live wallet\n- If a wallet already exists for the agent and type, it will be updated\n- Wallet address is automatically stored in the environment for use in other requests\n- Rate limited to 5 requests per minute per IP\n- Use `{{agent_id}}` environment variable or provide a valid UUID"
					},
					"response": []
				},
				{
					"name": "List Wallets",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"// Check if access token exists",
									"if (!pm.environment.get('access_token')) {",
									"    throw new Error('Access token not found. Please login first.');",
									"}",
									"",
									"// Check if agent_id exists",
									"if (!pm.environment.get('agent_id')) {",
									"    throw new Error('Agent ID not found. Please create an agent first.');",
									"}"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test('Status code is 200', function () {",
									"    pm.response.to.have.status(200);",
									"});",
									"",
									"pm.test('Response has agentWallets array', function () {",
									"    const response = pm.response.json();",
									"    pm.expect(response).to.have.property('agentWallets');",
									"    pm.expect(response.agentWallets).to.be.an('array');",
									"});",
									"",
									"pm.test('Response has availableWallets array', function () {",
									"    const response = pm.response.json();",
									"    pm.expect(response).to.have.property('availableWallets');",
									"    pm.expect(response.availableWallets).to.be.an('array');",
									"});",
									"",
									"if (pm.response.json().agentWallets.length > 0) {",
									"    pm.test('First agent wallet has required fields', function () {",
									"        const wallet = pm.response.json().agentWallets[0];",
									"        pm.expect(wallet).to.have.property('walletAddress');",
									"        pm.expect(wallet).to.have.property('walletType');",
									"",
									"        pm.expect(wallet).to.have.property('isAvailable');",
									"        pm.expect(wallet).to.have.property('createdAt');",
									"        ",
									"        // Store first wallet address if not already set",
									"        if (!pm.environment.get('wallet_address')) {",
									"            pm.environment.set('wallet_address', wallet.walletAddress);",
									"        }",
									"    });",
									"}",
									"",
									"if (pm.response.json().availableWallets.length > 0) {",
									"    pm.test('First available wallet has required fields', function () {",
									"        const wallet = pm.response.json().availableWallets[0];",
									"        pm.expect(wallet).to.have.property('walletAddress');",
									"        pm.expect(wallet).to.have.property('isAssigned');",
									"    });",
									"}"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": [
								{
									"key": "token",
									"value": "{{access_token}}",
									"type": "string"
								}
							]
						},
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{base_url}}/api/v1/wallets/agent/{{agent_id}}",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"api",
								"v1",
								"wallets",
								"agent",
								"{{agent_id}}"
							]
						},
						"description": "List all wallets for a specific agent and available wallets from environment variables. Returns both agent wallets (assigned to the agent) and available wallets (loaded from environment variables).\n\n## Headers\n\n```\nAuthorization: Bearer <access_token>\n```\n\n## Path Parameters\n\n- `agentId` (required): Agent ID (UUID)\n\n## Response\n\n```json\n{\n    \"agentWallets\": [\n        {\n            \"walletAddress\": \"Base58 encoded Solana address\",\n            \"walletType\": \"simulation\" | \"live\",\n            \"isAvailable\": true,\n            \"createdAt\": \"2025-01-27T12:00:00.000Z\",\n            \"updatedAt\": \"2025-01-27T12:00:00.000Z\"\n        }\n    ],\n    \"availableWallets\": [\n        {\n            \"walletAddress\": \"Base58 encoded Solana address\",\n            \"isAssigned\": false\n        }\n    ]\n}\n```\n\n## Error Responses\n\n- `400`: Invalid agent ID format\n- `401`: Unauthorized (missing or invalid token)\n- `404`: Agent not found\n- `500`: Internal server error\n\n## Notes\n\n- Requires authentication (access token in Authorization header)\n- Agent must belong to the authenticated user\n- `agentWallets`: Wallets assigned to the agent (simulation wallets are auto-created, live wallets are assigned from env vars)\n- `availableWallets`: Wallets loaded from environment variables (WALLET_1, WALLET_2, etc.) that can be assigned to agents\n- `isAvailable`: For live wallets, indicates if the wallet is loaded from environment variables. For simulation wallets, always true.\n- `isAssigned`: Indicates if the available wallet is already assigned to an agent\n- Wallets are ordered by creation date (most recent first)\n- Use `{{agent_id}}` environment variable or provide a valid UUID"
					},
					"response": []
				},
				{
					"name": "Reset Wallet",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"// Check if access token exists",
									"if (!pm.environment.get('access_token')) {",
									"    throw new Error('Access token not found. Please login first.');",
									"}",
									"",
									"// Check if wallet_address exists",
									"if (!pm.environment.get('wallet_address')) {",
									"    throw new Error('Wallet address not found. Please create a wallet first.');",
									"}"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"if (pm.response.code === 200) {",
									"    const response = pm.response.json();",
									"    ",
									"    pm.test('Status code is 200', function () {",
									"        pm.response.to.have.status(200);",
									"    });",
									"    ",
									"    pm.test('Response has success flag', function () {",
									"        pm.expect(response).to.have.property('success');",
									"        pm.expect(response.success).to.be.true;",
									"    });",
									"    ",
									"    pm.test('Response has message', function () {",
									"        pm.expect(response).to.have.property('message');",
									"        pm.expect(response.message).to.be.a('string');",
									"    });",
									"    ",
									"    pm.test('Response has deleted counts', function () {",
									"        pm.expect(response).to.have.property('deleted');",
									"        pm.expect(response.deleted).to.have.property('positions');",
									"        pm.expect(response.deleted).to.have.property('historicalSwaps');",
									"        pm.expect(response.deleted).to.have.property('balances');",
									"        pm.expect(response.deleted).to.have.property('transactions');",
									"    });",
									"    ",
									"    pm.test('Response has duration', function () {",
									"        pm.expect(response).to.have.property('duration');",
									"        pm.expect(response.duration).to.be.a('number');",
									"    });",
									"    ",
									"    console.log('Reset completed:', response.deleted);",
									"} else if (pm.response.code === 400) {",
									"    const response = pm.response.json();",
									"    if (response.message && response.message.includes('confirm')) {",
									"        pm.test('Confirmation required', function () {",
									"            pm.expect(response.error).to.equal('Confirmation required');",
									"        });",
									"    }",
									"} else {",
									"    pm.test('Reset wallet failed', function () {",
									"        pm.response.to.have.status(200);",
									"    });",
									"}"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": [
								{
									"key": "token",
									"value": "{{access_token}}",
									"type": "string"
								}
							]
						},
						"method": "POST",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n    \"confirm\": true\n}"
						},
						"url": {
							"raw": "{{base_url}}/api/v1/wallets/{{wallet_address}}/reset",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"api",
								"v1",
								"wallets",
								"{{wallet_address}}",
								"reset"
							]
						},
						"description": "Reset all trading data for a wallet while preserving the wallet itself. This clears:\n\n- All open positions (and removes from price tracking)\n- All historical swaps\n- All token balances\n- All transactions\n- All related Redis cache entries\n\n **WARNING**: This action cannot be undone. All trading data will be permanently deleted.\n\n## Headers\n\n```\nAuthorization: Bearer <access_token>\nContent-Type: application/json\n```\n\n## Path Parameters\n\n- `walletAddress` (required): Wallet address (Base58 encoded Solana address)\n\n## Request Body\n\n```json\n{\n    \"confirm\": true\n}\n```\n\n**Note**: The `confirm: true` field is required as a safety measure to prevent accidental resets.\n\n## Response\n\n```json\n{\n    \"success\": true,\n    \"message\": \"Wallet trading data reset successfully\",\n    \"walletAddress\": \"...\",\n    \"deleted\": {\n        \"positions\": 2,\n        \"historicalSwaps\": 5,\n        \"balances\": 3,\n        \"transactions\": 10\n    },\n    \"duration\": 150\n}\n```\n\n## Error Responses\n\n- `400`: Confirmation required or invalid request\n- `401`: Unauthorized (missing or invalid token)\n- `404`: Wallet not found\n- `429`: Too many requests (rate limited)\n- `500`: Internal server error\n\n## Notes\n\n- Requires authentication (access token in Authorization header)\n- Wallet must belong to an agent owned by the authenticated user\n- The wallet itself is preserved - only trading data is cleared\n- Position closed events are emitted, triggering price tracking cleanup\n- Both database and Redis cache are cleared atomically\n- Use `{{wallet_address}}` environment variable or provide a valid wallet address\n- Rate limited to prevent abuse"
					},
					"response": []
				}
			],
			"description": "Wallet management endpoints for assigning wallets from environment variables and resetting wallet trading data. Wallets are loaded from environment variables (WALLET_1, WALLET_2, etc.) at startup and are always available. Simulation wallets are auto-generated for agents. All endpoints require authentication and users can only access wallets for their own agents."
		},
		{
			"name": "Health & Monitoring",
			"item": [
				{
					"name": "Health Check",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"if (pm.response.code === 200 || pm.response.code === 503) {",
									"    const response = pm.response.json();",
									"    ",
									"    pm.test('Response has status field', function () {",
									"        pm.expect(response).to.have.property('status');",
									"        pm.expect(['healthy', 'degraded', 'unhealthy']).to.include(response.status);",
									"    });",
									"    ",
									"    pm.test('Response has services object', function () {",
									"        pm.expect(response).to.have.property('services');",
									"        pm.expect(response.services).to.be.an('object');",
									"    });",
									"    ",
									"    pm.test('Response has timestamp', function () {",
									"        pm.expect(response).to.have.property('timestamp');",
									"    });",
									"} else {",
									"    pm.test('Health check failed', function () {",
									"        pm.response.to.have.status([200, 503]);",
									"    });",
									"}"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{base_url}}/api/v1/health",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"api",
								"v1",
								"health"
							]
						},
						"description": "Get comprehensive health status of the application and its dependencies.\n\n## Response\n\n```json\n{\n    \"status\": \"healthy\",\n    \"timestamp\": \"2025-01-27T12:00:00.000Z\",\n    \"uptime\": 3600,\n    \"services\": {\n        \"database\": {\n            \"status\": \"healthy\",\n            \"latency\": 5\n        },\n        \"redis\": {\n            \"status\": \"healthy\",\n            \"latency\": 2\n        },\n        \"queue\": {\n            \"status\": \"healthy\"\n        }\n    }\n}\n```\n\n## Status Codes\n\n- `200`: Application is healthy or degraded (still operational)\n- `503`: Application is unhealthy (critical services down)\n\n## Response Fields\n\n- `status` (string): Overall status - `healthy`, `degraded`, or `unhealthy`\n- `timestamp` (string): ISO timestamp of the health check\n- `uptime` (number): Application uptime in seconds\n- `services` (object): Individual service health status\n  - `database` (object): Database connection status\n    - `status` (string): `healthy` or `unhealthy`\n    - `latency` (number, optional): Database query latency in milliseconds\n  - `redis` (object): Redis connection status\n    - `status` (string): `healthy` or `unhealthy`\n    - `latency` (number, optional): Redis operation latency in milliseconds\n  - `queue` (object): Queue worker status\n    - `status` (string): `healthy` or `unhealthy`\n\n## Notes\n\n- No authentication required\n- Returns `healthy` if all services are operational\n- Returns `degraded` if Redis or Queue is down (non-critical)\n- Returns `unhealthy` if Database is down (critical)\n- Useful for monitoring and load balancer health checks"
					},
					"response": []
				},
				{
					"name": "Readiness Probe",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"if (pm.response.code === 200 || pm.response.code === 503) {",
									"    const response = pm.response.json();",
									"    ",
									"    pm.test('Response has ready field', function () {",
									"        pm.expect(response).to.have.property('ready');",
									"        pm.expect(response.ready).to.be.a('boolean');",
									"    });",
									"} else {",
									"    pm.test('Readiness check failed', function () {",
									"        pm.response.to.have.status([200, 503]);",
									"    });",
									"}"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{base_url}}/api/v1/health/ready",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"api",
								"v1",
								"health",
								"ready"
							]
						},
						"description": "Check if the application is ready to accept traffic. Used by Kubernetes and other orchestration systems for readiness probes.\n\n## Response\n\n```json\n{\n    \"ready\": true,\n    \"timestamp\": \"2025-01-27T12:00:00.000Z\"\n}\n```\n\n## Status Codes\n\n- `200`: Application is ready to accept traffic\n- `503`: Application is not ready (e.g., during startup)\n\n## Response Fields\n\n- `ready` (boolean): Whether the application is ready\n- `timestamp` (string): ISO timestamp of the check\n- `degraded` (boolean, optional): Present if running in degraded mode (Redis unavailable)\n- `message` (string, optional): Additional information about readiness status\n\n## Notes\n\n- No authentication required\n- Application is ready if database is connected\n- Redis is preferred but not required for readiness\n- Used by Kubernetes `readinessProbe`"
					},
					"response": []
				},
				{
					"name": "Liveness Probe",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test('Status code is 200', function () {",
									"    pm.response.to.have.status(200);",
									"});",
									"",
									"if (pm.response.code === 200) {",
									"    const response = pm.response.json();",
									"    ",
									"    pm.test('Response has alive field', function () {",
									"        pm.expect(response).to.have.property('alive');",
									"        pm.expect(response.alive).to.be.true;",
									"    });",
									"    ",
									"    pm.test('Response has uptime', function () {",
									"        pm.expect(response).to.have.property('uptime');",
									"        pm.expect(response.uptime).to.be.a('number');",
									"    });",
									"}"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{base_url}}/api/v1/health/live",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"api",
								"v1",
								"health",
								"live"
							]
						},
						"description": "Check if the application process is alive. Used by Kubernetes and other orchestration systems for liveness probes.\n\n## Response\n\n```json\n{\n    \"alive\": true,\n    \"timestamp\": \"2025-01-27T12:00:00.000Z\",\n    \"uptime\": 3600\n}\n```\n\n## Status Codes\n\n- `200`: Application is alive (process is running)\n\n## Response Fields\n\n- `alive` (boolean): Always `true` if endpoint responds\n- `timestamp` (string): ISO timestamp of the check\n- `uptime` (number): Process uptime in seconds\n\n## Notes\n\n- No authentication required\n- Simple check that doesn't verify dependencies\n- Used by Kubernetes `livenessProbe`\n- Returns 200 as long as the process is running"
					},
					"response": []
				},
				{
					"name": "Prometheus Metrics",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test('Status code is 200', function () {",
									"    pm.response.to.have.status(200);",
									"});",
									"",
									"pm.test('Content type is text/plain', function () {",
									"    pm.expect(pm.response.headers.get('Content-Type')).to.include('text/plain');",
									"});",
									"",
									"pm.test('Response contains Prometheus metrics', function () {",
									"    const text = pm.response.text();",
									"    pm.expect(text).to.include('# HELP');",
									"    pm.expect(text).to.include('# TYPE');",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{base_url}}/api/v1/metrics",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"api",
								"v1",
								"metrics"
							]
						},
						"description": "Get Prometheus metrics in text format. This endpoint exposes all application metrics for Prometheus scraping.\n\n## Response\n\nPrometheus metrics in text format:\n\n```\n# HELP signal_processing_latency_seconds Time taken to process a trading signal\n# TYPE signal_processing_latency_seconds histogram\nsignal_processing_latency_seconds_bucket{status=\"success\",le=\"0.01\"} 10\nsignal_processing_latency_seconds_bucket{status=\"success\",le=\"0.05\"} 25\n...\n\n# HELP trade_execution_latency_seconds Time taken to execute a trade\n# TYPE trade_execution_latency_seconds histogram\ntrade_execution_latency_seconds_bucket{type=\"purchase\",status=\"success\",le=\"0.1\"} 5\n...\n```\n\n## Status Codes\n\n- `200`: Metrics retrieved successfully\n- `500`: Failed to retrieve metrics\n\n## Content Type\n\n- `text/plain; version=0.0.4; charset=utf-8`\n\n## Notes\n\n- No authentication required (for Prometheus scraping)\n- Returns metrics in Prometheus exposition format\n- Includes custom metrics:\n  - Signal processing latency and counts\n  - Trade execution latency and counts\n  - Stop loss evaluation latency and triggers\n  - Price update latency and counts\n  - Redis operation latency and counts\n  - Queue depth and job metrics\n  - API request metrics\n  - Error counts\n- Configure Prometheus to scrape this endpoint (typically every 15-30 seconds)\n- Metrics are cumulative counters and histograms"
					},
					"response": []
				}
			],
			"description": "Health check and monitoring endpoints for system observability. Health endpoints do not require authentication."
		},
		{
			"name": "API Keys",
			"item": [
				{
					"name": "Create API Key",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"// Check if access token exists",
									"if (!pm.environment.get('access_token')) {",
									"    throw new Error('Access token not found. Please login first.');",
									"}"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"if (pm.response.code === 201) {",
									"    const response = pm.response.json();",
									"    ",
									"    // Store API key info in environment",
									"    pm.environment.set('api_key_id', response.id);",
									"    pm.environment.set('api_key', response.key);",
									"    pm.environment.set('api_key_prefix', response.prefix);",
									"    ",
									"    pm.test('Status code is 201', function () {",
									"        pm.response.to.have.status(201);",
									"    });",
									"    ",
									"    pm.test('Response has id', function () {",
									"        pm.expect(response).to.have.property('id');",
									"    });",
									"    ",
									"    pm.test('Response has key (shown only once)', function () {",
									"        pm.expect(response).to.have.property('key');",
									"        pm.expect(response.key).to.match(/^nex_/);",
									"    });",
									"    ",
									"    pm.test('Response has prefix', function () {",
									"        pm.expect(response).to.have.property('prefix');",
									"        pm.expect(response.prefix).to.match(/^nex_/);",
									"    });",
									"    ",
									"    pm.test('Response has scopes', function () {",
									"        pm.expect(response).to.have.property('scopes');",
									"        pm.expect(response.scopes).to.be.an('array');",
									"    });",
									"    ",
									"    pm.test('Response has createdAt', function () {",
									"        pm.expect(response).to.have.property('createdAt');",
									"    });",
									"} else {",
									"    pm.test('Request failed', function () {",
									"        pm.response.to.have.status(201);",
									"    });",
									"}"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": [
								{
									"key": "token",
									"value": "{{access_token}}",
									"type": "string"
								}
							]
						},
						"method": "POST",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json",
								"type": "text"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n    \"name\": \"Signal Engine Integration\",\n    \"scopes\": [\"signals\"]\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{base_url}}/api/v1/api-keys",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"api",
								"v1",
								"api-keys"
							]
						},
						"description": "Create a new API key for programmatic access.\n\n## Headers\n\n```\nAuthorization: Bearer <access_token>\nContent-Type: application/json\n```\n\n## Request Body\n\n```json\n{\n    \"name\": \"Signal Engine Integration\",\n    \"scopes\": [\"signals\"]\n}\n```\n\n## Request Fields\n\n- `name` (string, required): User-friendly name for the API key (1-100 characters)\n- `scopes` (string[], required): Array of permission scopes:\n  - `signals`: Can create trading signals only\n  - `full_access`: Full API access (same as JWT)\n\n## Response\n\n```json\n{\n    \"id\": \"uuid\",\n    \"name\": \"Signal Engine Integration\",\n    \"key\": \"nex_a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6\",\n    \"prefix\": \"nex_a1b2\",\n    \"scopes\": [\"signals\"],\n    \"createdAt\": \"2026-01-18T12:00:00.000Z\"\n}\n```\n\n## IMPORTANT\n\n- The `key` field is **shown only once** in this response\n- Store it securely - it cannot be retrieved later\n- Use the `prefix` to identify the key in the future\n\n## Error Responses\n\n- `400`: Invalid input (missing/invalid name or scopes)\n- `401`: Unauthorized (missing or invalid access token)\n- `500`: Internal server error"
					},
					"response": []
				},
				{
					"name": "List API Keys",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"// Check if access token exists",
									"if (!pm.environment.get('access_token')) {",
									"    throw new Error('Access token not found. Please login first.');",
									"}"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"if (pm.response.code === 200) {",
									"    const response = pm.response.json();",
									"    ",
									"    pm.test('Status code is 200', function () {",
									"        pm.response.to.have.status(200);",
									"    });",
									"    ",
									"    pm.test('Response has items array', function () {",
									"        pm.expect(response).to.have.property('items');",
									"        pm.expect(response.items).to.be.an('array');",
									"    });",
									"    ",
									"    if (response.items.length > 0) {",
									"        pm.test('API key items have correct structure', function () {",
									"            const key = response.items[0];",
									"            pm.expect(key).to.have.property('id');",
									"            pm.expect(key).to.have.property('name');",
									"            pm.expect(key).to.have.property('prefix');",
									"            pm.expect(key).to.have.property('scopes');",
									"            pm.expect(key).to.have.property('createdAt');",
									"            // key field should NOT be present",
									"            pm.expect(key).to.not.have.property('key');",
									"        });",
									"    }",
									"} else {",
									"    pm.test('Request failed', function () {",
									"        pm.response.to.have.status(200);",
									"    });",
									"}"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": [
								{
									"key": "token",
									"value": "{{access_token}}",
									"type": "string"
								}
							]
						},
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{base_url}}/api/v1/api-keys",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"api",
								"v1",
								"api-keys"
							]
						},
						"description": "List all API keys for the authenticated user.\n\n## Headers\n\n```\nAuthorization: Bearer <access_token>\n```\n\n## Response\n\n```json\n{\n    \"items\": [\n        {\n            \"id\": \"uuid\",\n            \"name\": \"Signal Engine Integration\",\n            \"prefix\": \"nex_a1b2\",\n            \"scopes\": [\"signals\"],\n            \"createdAt\": \"2026-01-18T12:00:00.000Z\"\n        }\n    ]\n}\n```\n\n## Notes\n\n- The raw API key is **never** returned after creation\n- Use the `prefix` to identify keys\n- Keys are sorted by creation date (newest first)\n\n## Error Responses\n\n- `401`: Unauthorized (missing or invalid access token)\n- `500`: Internal server error"
					},
					"response": []
				},
				{
					"name": "Get API Key",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"// Check if access token exists",
									"if (!pm.environment.get('access_token')) {",
									"    throw new Error('Access token not found. Please login first.');",
									"}",
									"",
									"// Check if api_key_id exists",
									"if (!pm.environment.get('api_key_id')) {",
									"    throw new Error('API key ID not found. Please create an API key first.');",
									"}"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"if (pm.response.code === 200) {",
									"    const response = pm.response.json();",
									"    ",
									"    pm.test('Status code is 200', function () {",
									"        pm.response.to.have.status(200);",
									"    });",
									"    ",
									"    pm.test('Response has id', function () {",
									"        pm.expect(response).to.have.property('id');",
									"    });",
									"    ",
									"    pm.test('Response has name', function () {",
									"        pm.expect(response).to.have.property('name');",
									"    });",
									"    ",
									"    pm.test('Response has prefix', function () {",
									"        pm.expect(response).to.have.property('prefix');",
									"    });",
									"    ",
									"    pm.test('Response has scopes', function () {",
									"        pm.expect(response).to.have.property('scopes');",
									"    });",
									"    ",
									"    pm.test('Response does NOT have raw key', function () {",
									"        pm.expect(response).to.not.have.property('key');",
									"    });",
									"} else {",
									"    pm.test('Request failed', function () {",
									"        pm.response.to.have.status(200);",
									"    });",
									"}"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": [
								{
									"key": "token",
									"value": "{{access_token}}",
									"type": "string"
								}
							]
						},
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{base_url}}/api/v1/api-keys/{{api_key_id}}",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"api",
								"v1",
								"api-keys",
								"{{api_key_id}}"
							]
						},
						"description": "Get details of a specific API key.\n\n## Headers\n\n```\nAuthorization: Bearer <access_token>\n```\n\n## Path Parameters\n\n- `id`: The API key UUID\n\n## Response\n\n```json\n{\n    \"id\": \"uuid\",\n    \"name\": \"Signal Engine Integration\",\n    \"prefix\": \"nex_a1b2\",\n    \"scopes\": [\"signals\"],\n    \"createdAt\": \"2026-01-18T12:00:00.000Z\"\n}\n```\n\n## Notes\n\n- The raw API key is **never** returned\n- Users can only access their own API keys\n\n## Error Responses\n\n- `400`: Invalid API key ID format\n- `401`: Unauthorized (missing or invalid access token)\n- `404`: API key not found\n- `500`: Internal server error"
					},
					"response": []
				},
				{
					"name": "Delete API Key",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"// Check if access token exists",
									"if (!pm.environment.get('access_token')) {",
									"    throw new Error('Access token not found. Please login first.');",
									"}",
									"",
									"// Check if api_key_id exists",
									"if (!pm.environment.get('api_key_id')) {",
									"    throw new Error('API key ID not found. Please create an API key first.');",
									"}"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"if (pm.response.code === 200) {",
									"    const response = pm.response.json();",
									"    ",
									"    // Clear the API key from environment",
									"    pm.environment.unset('api_key_id');",
									"    pm.environment.unset('api_key');",
									"    pm.environment.unset('api_key_prefix');",
									"    ",
									"    pm.test('Status code is 200', function () {",
									"        pm.response.to.have.status(200);",
									"    });",
									"    ",
									"    pm.test('Response has success flag', function () {",
									"        pm.expect(response).to.have.property('success');",
									"        pm.expect(response.success).to.be.true;",
									"    });",
									"    ",
									"    pm.test('Response has message', function () {",
									"        pm.expect(response).to.have.property('message');",
									"    });",
									"} else {",
									"    pm.test('Request failed', function () {",
									"        pm.response.to.have.status(200);",
									"    });",
									"}"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": [
								{
									"key": "token",
									"value": "{{access_token}}",
									"type": "string"
								}
							]
						},
						"method": "DELETE",
						"header": [],
						"url": {
							"raw": "{{base_url}}/api/v1/api-keys/{{api_key_id}}",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"api",
								"v1",
								"api-keys",
								"{{api_key_id}}"
							]
						},
						"description": "Delete (revoke) an API key.\n\n## Headers\n\n```\nAuthorization: Bearer <access_token>\n```\n\n## Path Parameters\n\n- `id`: The API key UUID\n\n## Response\n\n```json\n{\n    \"success\": true,\n    \"message\": \"API key deleted successfully\"\n}\n```\n\n## Notes\n\n- This action is permanent - deleted keys cannot be recovered\n- Any requests using the deleted key will immediately fail\n- Users can only delete their own API keys\n\n## Error Responses\n\n- `400`: Invalid API key ID format\n- `401`: Unauthorized (missing or invalid access token)\n- `404`: API key not found\n- `500`: Internal server error"
					},
					"response": []
				},
				{
					"name": "Test API Key - Create Trading Signal",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"// Check if API key exists",
									"if (!pm.environment.get('api_key')) {",
									"    throw new Error('API key not found. Please create an API key first.');",
									"}"
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"if (pm.response.code === 201) {",
									"    const response = pm.response.json();",
									"    ",
									"    pm.test('Status code is 201', function () {",
									"        pm.response.to.have.status(201);",
									"    });",
									"    ",
									"    pm.test('Trading signal created successfully', function () {",
									"        pm.expect(response).to.have.property('id');",
									"        pm.expect(response).to.have.property('tokenAddress');",
									"        pm.expect(response).to.have.property('signalType');",
									"        pm.expect(response).to.have.property('signalStrength');",
									"    });",
									"} else if (pm.response.code === 401) {",
									"    pm.test('Authentication failed (check API key)', function () {",
									"        pm.response.to.have.status(401);",
									"    });",
									"} else if (pm.response.code === 403) {",
									"    pm.test('Missing signals scope', function () {",
									"        pm.response.to.have.status(403);",
									"    });",
									"} else {",
									"    pm.test('Request failed', function () {",
									"        pm.response.to.have.status(201);",
									"    });",
									"}"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"auth": {
							"type": "noauth"
						},
						"method": "POST",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json",
								"type": "text"
							},
							{
								"key": "X-API-Key",
								"value": "{{api_key}}",
								"type": "text"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n    \"tokenAddress\": \"So11111111111111111111111111111111111111112\",\n    \"symbol\": \"SOL\",\n    \"signalType\": \"momentum\",\n    \"signalStrength\": 4,\n    \"activationReason\": \"API key test signal\",\n    \"source\": \"postman-test\"\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{base_url}}/api/v1/trading-signals",
							"host": [
								"{{base_url}}"
							],
							"path": [
								"api",
								"v1",
								"trading-signals"
							]
						},
						"description": "Test API key authentication by creating a trading signal.\n\n## Headers\n\n```\nX-API-Key: nex_xxxxx\nContent-Type: application/json\n```\n\n## Request Body\n\n```json\n{\n    \"tokenAddress\": \"So11111111111111111111111111111111111111112\",\n    \"symbol\": \"SOL\",\n    \"signalType\": \"momentum\",\n    \"signalStrength\": 4,\n    \"activationReason\": \"API key test signal\",\n    \"source\": \"external-system\"\n}\n```\n\n## Notes\n\n- This endpoint uses the **X-API-Key** header instead of JWT\n- The API key must have the `signals` scope\n- Rate limited to 120 requests per minute per API key\n\n## Error Responses\n\n- `401`: API key required or invalid\n- `403`: API key missing `signals` scope\n- `429`: Rate limit exceeded (120 requests/minute)\n- `500`: Internal server error"
					},
					"response": []
				}
			],
			"description": "API key management endpoints for programmatic access to the Nexgent API. API keys allow external applications (like the Nexgent signal engine) to authenticate without using JWT tokens.\n\n## Usage\n\n1. **Create an API key** using JWT authentication\n2. **Store the key securely** - it's only shown once\n3. **Use the key** in the `X-API-Key` header for requests\n\n## Scopes\n\n- `signals`: Can create trading signals only (POST /api/v1/trading-signals)\n- `full_access`: Full API access (same permissions as JWT)\n\n## Rate Limits\n\n- API key requests are rate limited to 120 requests per minute per key\n\n## Security Notes\n\n- API keys are hashed before storage - the raw key is shown only once\n- Use the prefix to identify keys in the UI\n- Delete keys immediately if compromised"
		}
	],
	"event": [
		{
			"listen": "prerequest",
			"script": {
				"type": "text/javascript",
				"exec": [
					"// Global pre-request script",
					"// This runs before every request in the collection",
					"",
					"// Ensure base_url is set",
					"if (!pm.environment.get('base_url')) {",
					"    pm.environment.set('base_url', 'http://localhost:4000');",
					"}"
				]
			}
		},
		{
			"listen": "test",
			"script": {
				"type": "text/javascript",
				"exec": [
					"// Global test script",
					"// This runs after every request in the collection",
					"",
					"// Log response time",
					"pm.test('Response time is less than 5000ms', function () {",
					"    pm.expect(pm.response.responseTime).to.be.below(5000);",
					"});"
				]
			}
		}
	],
	"variable": [
		{
			"key": "base_url",
			"value": "http://localhost:4000",
			"type": "string"
		}
	]
}